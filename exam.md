
## Оглавление
<details><summary>Вопросы без таблиц и запросов</summary>

1. [Вопросы без таблиц и запросов](#вопросы-без-таблиц-и-запросов) 
    1. [Вопрос 1](#вопрос-1)
    2. [Вопрос 2](#вопрос-2)
    3. [Вопрос 3](#вопрос-3)
    4. [Вопрос 4](#вопрос-4)
    5. [Вопрос 5](#вопрос-5)
    6. [Вопрос 6](#вопрос-6)
    7. [Вопрос 7](#вопрос-7)
    8. [Вопрос 8](#вопрос-8)
    9. [Вопрос 9](#вопрос-9)
    10. [Вопрос 10](#вопрос-10)
    11. [Вопрос 11](#вопрос-11)
    12. [Вопрос 12](#вопрос-12)
    13. [Вопрос 13](#вопрос-13)
    14. [Вопрос 14](#вопрос-14)
    15. [Вопрос 15](#вопрос-15)
    16. [Вопрос 16](#вопрос-16)
    17. [Вопрос 17](#вопрос-17)
    18. [Вопрос 18](#вопрос-18)
    19. [Вопрос 19](#вопрос-19)
    20. [Вопрос 20](#вопрос-20)
    21. [Вопрос 21](#вопрос-21)
    22. [Вопрос 22](#вопрос-22)
    23. [Вопрос 23](#вопрос-23)
    24. [Вопрос 24](#вопрос-24)
    25. [Вопрос 25](#вопрос-25)
    26. [Вопрос 26](#вопрос-26)
    27. [Вопрос 27](#вопрос-27)
    28. [Вопрос 28](#вопрос-28)
    29. [Вопрос 29](#вопрос-29)
    30. [Вопрос 30](#вопрос-30)
    31. [Вопрос 31](#вопрос-31)
    32. [Вопрос 32](#вопрос-32)
    33. [Вопрос 33](#вопрос-33)
    34. [Вопрос 34](#вопрос-34)
    35. [Вопрос 35](#вопрос-35)
    36. [Вопрос 36](#вопрос-36)
    37. [Вопрос 37](#вопрос-37)
    38. [Вопрос 38](#вопрос-38)
    39. [Вопрос 39](#вопрос-39)
    40. [Вопрос 40](#вопрос-40)
    41. [Вопрос 41](#вопрос-41)
    42. [Вопрос 42](#вопрос-42)
    43. [Вопрос 43](#вопрос-43)
    44. [Вопрос 44](#вопрос-44)
    45. [Вопрос 45](#вопрос-45)
    46. [Вопрос 46](#вопрос-46)
    47. [Вопрос 47](#вопрос-47)
    48. [Вопрос 48](#вопрос-48)
    49. [Вопрос 49](#вопрос-49)
    50. [Вопрос 50](#вопрос-50)
    51. [Вопрос 51](#вопрос-51)
    52. [Вопрос 52](#вопрос-52)
    53. [Вопрос 53](#вопрос-53)
    54. [Вопрос 54](#вопрос-54)
    55. [Вопрос 55](#вопрос-55)
    56. [Вопрос 56](#вопрос-56)

</details>
<details><summary>2. Вопросы с таблицами и запросами</summary>

2. Вопросы с таблицами и запросами

    57. [Вопрос 57](#вопрос-57)
    58. [Вопрос 58](#вопрос-58)
    59. [Вопрос 59](#вопрос-59)
    60. [Вопрос 60](#вопрос-60)
    61. [Вопрос 61](#вопрос-61)
    62. [Вопрос 62](#вопрос-62)
    63. [Вопрос 63](#вопрос-63)
    64. [Вопрос 64](#вопрос-64)
    65. [Вопрос 65](#вопрос-65)
    66. [Вопрос 66](#вопрос-66)
    67. [Вопрос 67](#вопрос-67)
    68. [Вопрос 68](#вопрос-68)
    69. [Вопрос 69](#вопрос-69)
    70. [Вопрос 70](#вопрос-70)
    71. [Вопрос 71](#вопрос-71)
    72. [Вопрос 72](#вопрос-72)
    73. [Вопрос 73](#вопрос-73)
    74. [Вопрос 74](#вопрос-74)
    75. [Вопрос 75](#вопрос-75)
    76. [Вопрос 76](#вопрос-76)
    77. [Вопрос 77](#вопрос-77)
    78. [Вопрос 78](#вопрос-78)
    79. [Вопрос 79](#вопрос-79)
    80. [Вопрос 80](#вопрос-80)
    81. [Вопрос 81](#вопрос-81)
    82. [Вопрос 82](#вопрос-82)
    83. [Вопрос 83](#вопрос-83)
    84. [Вопрос 84](#вопрос-84)
    85. [Вопрос 85](#вопрос-85)
    86. [Вопрос 86](#вопрос-86)
    87. [Вопрос 87](#вопрос-87)
    88. [Вопрос 88](#вопрос-88)
    89. [Вопрос 89](#вопрос-89)
    90. [Вопрос 90](#вопрос-90)
    91. [Вопрос 91](#вопрос-91)
    92. [Вопрос 92](#вопрос-92)
    93. [Вопрос 93](#вопрос-93)
    94. [Вопрос 94](#вопрос-94)
    95. [Вопрос 95](#вопрос-95)
    96. [Вопрос 96](#вопрос-96)

</details>

## Вопросы без таблиц и запросов 

#### Вопрос 1
Что концептуально представляют собой атрибуты сущности в ER-модели?

- [x] Характеристики или свойства сущности, которые описывают данные, относящиеся к этой сущности.
- [ ] Объекты или вещи в системе.
- [ ] Отношения между сущностями.
- [ ] Уникальные идентификаторы сущностей.

[↑ Вернуться к оглавлению](#оглавление)


#### Вопрос 2
Какой из языков обычно используется для описания логических моделей данных?

- [ ] HTML
- [ ] UML
- [ ] JSON
- [x] SQL

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 3
Какое из следующих понятий описывает связь между двумя сущностями в логической модели данных?

- [ ] Хеш-код
- [ ] Тригер
- [ ] Индекс
- [x] Внешний ключ (Foreign Key)

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 4
Что представляет собой первая нормальная форма (1NF) в реляционном дизайне баз данных?

- [x] Все значения атрибутов атомарные (неделимые), каждый столбец содержит только одно значение.
- [ ] Наличие уникального идентификатора для каждой записи.
- [ ] Сущность имеет как минимум один атрибут.
- [ ] Поддержание ссылочной целостности.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 5
Что такое первичный ключ в физической модели данных?

- [x] Уникальный идентификатор строки в таблице, который однозначно определяет каждую запись.
- [ ] Свойство сущности, описывающее данные.
- [ ] Атрибут, который может принимать только уникальные значения.
- [ ] Показатель, определяющий количество связей между сущностями.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 6
Какое действие будет предпринято, если объект CHECK CONSTRAINT не пройдет при вставке или обновлении данных?

- [ ] Данные будут вставлены/обновлены, но с предупреждением.
- [ ] Данные будут вставлены/обновлены без изменений.
- [x] Вызвано исключение, и операция не будет выполнена.
- [ ] Будет выполнена попытка исправить данные автоматически.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 7
Какая команда используется для создания FOREIGN KEY?

- [x] ALTER TABLE ... ADD CONSTRAINT ... FOREIGN KEY
- [ ] CREATE TABLE ... FOREIGN KEY
- [ ] ADD FOREIGN KEY TO TABLE ...
- [ ] MODIFY TABLE ... ADD FOREIGN KEY

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 8
Какая DDL команда используется для создания CHECK CONSTRAINT?

- [x] ALTER TABLE ... ADD CONSTRAINT ... CHECK
- [ ] CREATE TABLE ... CHECK CONSTRAINT
- [ ] ADD CHECK CONSTRAINT TO TABLE ...
- [ ] MODIFY TABLE ... ADD CHECK

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 9
Что подходит под термин <Реляционная база данных>?

- [x] База данных, которая использует реляционную модель для хранения и управления данными.
- [ ] База данных, которая использует объектно-ориентированную модель для хранения данных.
- [ ] Файловая система, использующая реляционные таблицы.
- [ ] База данных, работающая на основе графовых данных.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 10


Что представляет собой "схемы базы данных" в контексте логического моделирования данных?

- **Диаграмма**  
  *Часто используется для визуализации схемы базы данных, включая таблицы и связи между ними.*

- [x] **Математическое описание**  
  *Схемы баз данных могут быть описаны с помощью формальных языков, таких как язык описания данных (DDL), который используется для определения структуры данных.*

- **Физические данных на диске**  
  *Это описание не относится к логической схеме базы данных, а касается физической реализации, как данные фактически хранятся на диске.*

- **Описание запросов в виде реализации алгебр**  
  *Хотя запросы и могут использовать операции реляционной алгебры для манипуляции данными, описание самих запросов не является частью схемы базы данных.*

### Правильный ответ:

**Математическое описание**  
*В контексте логического моделирования, схема базы данных представляет собой математическое описание структуры данных. Диаграмма также может быть использована для визуального представления этой структуры, но математическое описание является более фундаментальным в контексте определения и понимания структуры базы данных на логическом уровне.*

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 11
Кто управляет доступами к данным в реляционной базе данных?

- [x] DBMS (Database Management System)
- [ ] quercy optimaze
- [ ] transacthion
- [ ] sql serve

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 12
Что означает аббревиатура <CAP> в концепции CAP-теоремы?

- [x] Consistency (Согласованность), Availability (Доступность), Partition Tolerance (Устойчивость к разделению сети)
- [ ] Consistency (Согласованность), Accuracy (Точность), Performance (Производительность)
- [ ] Control (Контроль), Availability (Доступность), Partition (Разделение)
- [ ] Consistency (Согласованность), Availability (Доступность), Performance (Производительность)

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 13
Какой принцип гарантии ACID гарантирует, что если транзакция прошла успешно, изменения будут сохранены даже в случае сбоя системы?

- [x] Долговечность (Durability)
- [ ] Атомарность (Atomicity)
- [ ] Согласованность (Consistency)
- [ ] Изолированность (Isolation)

[↑ Вернуться к оглавлению](#оглавление)


### Вопрос 14

При попытке удаления записи из родительской таблицы сущности с установленным внешним ключом (FOREIGN KEY) и параметром `ON DELETE CASCADE`, что произойдет?

- [ ] Запись в родительской таблице будет удалена, а записи в дочерней таблице останутся без изменений.
- [ ] Будет вызвано исключение, и запись не будет удалена.
- [ ] Запись в родительской таблице будет удалена, а связанные записи в дочерней таблице будут обновлены.
- [x] Запись в родительской таблице будет удалена, и все связанные записи в дочерней таблице также будут автоматически удалены.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 15

Какие типы индексов используются в реляционных базах данных?

- [ ] Гибкие (Flexible)
- [ ] Кластерные (Clustered)
- [x] Полнотекстовые (Full-Text)
- [x] Уникальные (Unique)

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 16

Какова цель логического моделирования данных?

- [ ] Обеспечить физическое хранение данных на диске.
- [ ] Оптимизировать запросы к базе данных.
- [ ] Определить структуру базы данных, не зависящую от СУБД.
- [x] Описать данные и их отношения на концептуальном уровне, независимо от физического хранения.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Описать данные и их отношения на концептуальном уровне, независимо от физического хранения**:
  - Логическое моделирование данных направлено на создание абстрактной модели, которая описывает данные и их отношения без привязки к конкретной СУБД или физическим аспектам хранения данных. Эта модель помогает понять структуру данных и их взаимосвязи на высоком уровне.

### Неправильные ответы

- **Обеспечить физическое хранение данных на диске**:
  - Это задача физического моделирования данных, а не логического.

- **Оптимизировать запросы к базе данных**:
  - Оптимизация запросов относится к аспектам реализации и выполнения запросов, что также выходит за рамки логического моделирования данных.

- **Определить структуру базы данных, не зависящую от СУБД**:
  - Логическое моделирование действительно определяет структуру данных, но этот ответ не полностью отражает цель описания данных и их отношений на концептуальном уровне.


### Вопрос 17 

Какой метод используется для нормализации логических моделей данных?

- [ ] Индексация
- [ ] Кэширование
- [x] Нормализация
- [ ] Репликация

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Нормализация**:
  - Нормализация – это метод, используемый для организации атрибутов и таблиц реляционной базы данных для минимизации избыточности данных и предотвращения аномалий при обновлении. Она включает в себя применение различных нормальных форм (1NF, 2NF, 3NF и т.д.), чтобы обеспечить логическую согласованность и целостность данных.

### Неправильные ответы

- **Индексация**:
  - Индексация используется для ускорения выполнения запросов, но не для нормализации данных.

- **Кэширование**:
  - Кэширование используется для хранения часто запрашиваемых данных в памяти для быстрого доступа, но не связано с нормализацией данных.

- **Репликация**:
  - Репликация используется для создания копий данных для обеспечения их доступности и отказоустойчивости, но не для нормализации данных.

### Вопрос 18

Что такое CHECK CONSTRAINT в реляционной базе данных?

- [ ] Ограничение, которое гарантирует, что все значения в столбце являются уникальными.
- [x] Ограничение, которое гарантирует, что все значения в столбце или наборе столбцов удовлетворяют определенному логическому условию.
- [ ] Ограничение, которое устанавливает связь между двумя таблицами.
- [ ] Ограничение, которое предотвращает удаление строк из таблицы.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CHECK CONSTRAINT**:
  - CHECK CONSTRAINT (ограничение проверки) используется для обеспечения того, что все значения в столбце или наборе столбцов соответствуют заданному логическому условию. Это условие может включать проверку диапазона значений, соответствие шаблону или любую другую логическую проверку, определенную пользователем.

### Неправильные ответы

- **Ограничение, которое гарантирует, что все значения в столбце являются уникальными**:
  - Это описание UNIQUE CONSTRAINT, а не CHECK CONSTRAINT.

- **Ограничение, которое устанавливает связь между двумя таблицами**:
  - Это описание FOREIGN KEY CONSTRAINT.

- **Ограничение, которое предотвращает удаление строк из таблицы**:
  - Это не связано с CHECK CONSTRAINT. Это может быть связано с другими мерами безопасности или ограничениями в базе данных.

### Вопрос 19

Какой из перечисленных факторов НЕ влияет на процесс проектирования физической модели базы данных?

- [x] Инструмент проектирования физической модели
- [ ] Сложность бизнес-логики
- [ ] Объем данных
- [ ] Требования к производительности

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Инструмент проектирования физической модели**:
  - Инструмент проектирования может влиять на удобство и скорость работы, но не на сам процесс проектирования физической модели базы данных. Факторы, связанные с архитектурой, объемом данных и производительностью, оказывают непосредственное влияние на проектирование.

### Неправильные ответы

- **Сложность бизнес-логики**:
  - Сложность бизнес-логики влияет на проектирование физической модели, так как более сложная логика может требовать более сложных структур данных и индексов.

- **Объем данных**:
  - Объем данных напрямую влияет на процесс проектирования физической модели, так как большой объем данных может требовать особого подхода к хранению и индексации для обеспечения производительности и масштабируемости.

- **Требования к производительности**:
  - Требования к производительности сильно влияют на процесс проектирования физической модели, так как они определяют, как данные должны быть распределены и индексированы для обеспечения оптимальной производительности.

### Вопрос 20

Какая команда DDL используется для добавления ограничения CHECK CONSTRAINT в уже существующую таблицу?

- [ ] CREATE TABLE ... ADD CONSTRAINT ... CHECK
- [ ] ALTER TABLE ... MODIFY CONSTRAINT ... CHECK
- [x] ALTER TABLE ... ADD CONSTRAINT ... CHECK
- [ ] UPDATE TABLE ... ADD CONSTRAINT ... CHECK

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **ALTER TABLE ... ADD CONSTRAINT ... CHECK**:
  - Эта команда используется для добавления ограничения CHECK в уже существующую таблицу. Она позволяет определить условие, которому должны соответствовать данные в столбце или наборе столбцов.

### Пример использования

```sql
ALTER TABLE table_name
ADD CONSTRAINT constraint_name CHECK (condition);
```
### Вопрос 21

Какая команда DDL используется для создания уникального индекса в реляционной базе данных?

- [ ] CREATE TABLE ... UNIQUE INDEX
- [ ] ALTER TABLE ... ADD UNIQUE INDEX
- [x] CREATE UNIQUE INDEX ... ON ...
- [ ] UPDATE TABLE ... ADD UNIQUE INDEX

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CREATE UNIQUE INDEX ... ON ...**:
  - Эта команда используется для создания уникального индекса на столбце или наборе столбцов в уже существующей таблице. Уникальный индекс гарантирует, что все значения в индексируемых столбцах будут уникальными.

### Пример использования

```sql
CREATE UNIQUE INDEX index_name 
ON table_name (column_name);
```
### Вопрос 22

Что означает уровень изоляции транзакций `READ UNCOMMITTED` в реляционной базе данных?

- [ ] Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями.
- [ ] Транзакция может видеть изменения, которые были зафиксированы другими транзакциями, но не свои собственные.
- [x] Транзакция может видеть все изменения, включая те, которые еще не были зафиксированы другими транзакциями.
- [ ] Транзакция не может видеть никакие изменения, пока они не будут зафиксированы.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Транзакция может видеть все изменения, включая те, которые еще не были зафиксированы другими транзакциями**:
  - Уровень изоляции `READ UNCOMMITTED` позволяет транзакции читать данные, которые были изменены другими транзакциями, но еще не были зафиксированы. Это может привести к ситуации, известной как "грязное чтение" (dirty read), где транзакция читает данные, которые могут быть впоследствии откатаны.

### Неправильные ответы

- **Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями**:
  - Это описание уровня изоляции `READ COMMITTED`.

- **Транзакция может видеть изменения, которые были зафиксированы другими транзакциями, но не свои собственные**:
  - Нет такого стандартного уровня изоляции в SQL.

- **Транзакция не может видеть никакие изменения, пока они не будут зафиксированы**:
  - Это описание более строгого уровня изоляции, например, `SERIALIZABLE`.


### Вопрос 23

Какие из перечисленных операций являются пользовательскими операциями в реляционной базе данных?

- [ ] JSON
- [ ] RAD
- [ ] HTTP
- [x] CRUD

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CRUD**:
  - CRUD — это аббревиатура, обозначающая четыре основные операции, которые выполняются пользователями в реляционной базе данных: Create (создание), Read (чтение), Update (обновление), Delete (удаление). Эти операции являются основными для работы с данными в базе данных и позволяют пользователям взаимодействовать с хранимыми данными.

### Неправильные ответы

- **JSON**:
  - JSON (JavaScript Object Notation) — это формат данных для передачи и хранения структурированных данных, но не является пользовательской операцией в реляционной базе данных.

- **RAD**:
  - RAD (Rapid Application Development) — это методология быстрой разработки приложений, а не пользовательская операция в реляционной базе данных.

- **HTTP**:
  - HTTP (Hypertext Transfer Protocol) — это протокол передачи гипертекста, используемый в сети Интернет, но не является пользовательской операцией в реляционной базе данных.

### Вопрос 24

Какие типы баз данных наиболее подходят для работы с социальными сетями и рекомендательными системами?

- [ ] Реляционные базы данных (Relational)
- [ ] Документно-ориентированные базы данных (Document)
- [x] NoSQL базы данных (NoSQL)
- [x] Графовые базы данных (Graph)

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **NoSQL базы данных (NoSQL)**:
   - NoSQL базы данных часто используются для работы с большими объемами неструктурированных данных и обеспечивают высокую производительность и масштабируемость. Они могут быть полезны для хранения и обработки данных социальных сетей и рекомендательных систем.

2. **Графовые базы данных (Graph)**:
   - Графовые базы данных особенно подходят для работы с данными социальных сетей, где важны связи и взаимодействия между пользователями. Они позволяют эффективно хранить и запрашивать данные о связях и рекомендациях.

### Неправильные ответы

- **Реляционные базы данных (Relational)**:
  - Хотя реляционные базы данных могут использоваться для некоторых задач в социальных сетях и рекомендательных системах, они могут не справляться с задачами, требующими масштабируемости и гибкости, особенно при работе с большими объемами данных и сложными связями.

- **Документно-ориентированные базы данных (Document)**:
  - Документно-ориентированные базы данных подходят для хранения данных в формате документов, но они не всегда оптимальны для задач, связанных с анализом сложных взаимосвязей, которые характерны для социальных сетей и рекомендательных систем.

### Вопрос 25

Что представляет собой отношение (таблица) в реляционной базе данных?

- [ ] Набор документов, хранящихся в формате JSON.
- [ ] Граф данных, отображающий связи между узлами.
- [x] Множество строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут.
- [ ] Структура данных, организованная в виде ключ-значение.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Множество строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут**:
  - В реляционной базе данных отношение (таблица) представляет собой двумерную структуру данных, состоящую из строк (записей) и столбцов (атрибутов). Каждая строка в таблице соответствует одной записи, а каждый столбец соответствует одному атрибуту записи. Таблицы используются для хранения и организации данных в реляционных базах данных.

### Неправильные ответы

- **Набор документов, хранящихся в формате JSON**:
  - Это описание документно-ориентированных баз данных, а не реляционных.

- **Граф данных, отображающий связи между узлами**:
  - Это описание графовых баз данных, а не реляционных.

- **Структура данных, организованная в виде ключ-значение**:
  - Это описание базы данных типа ключ-значение, а не реляционных баз данных.

### Вопрос 26

Какие базы данных удовлетворяют свойствам "CA" (Consistency and Availability) из CAP-теоремы?

- [x] PostgreSQL
- [x] MySQL
- [ ] Cassandra
- [ ] HBase

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **PostgreSQL**:
   - PostgreSQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

2. **MySQL**:
   - MySQL — это еще одна реляционная база данных, которая также обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

### Неправильные ответы

- **Cassandra**:
  - Cassandra — это распределенная база данных, которая акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но не всегда на согласованности (Consistency).

- **HBase**:
  - HBase — это распределенная, масштабируемая база данных, которая также акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но не всегда на согласованности (Consistency).

### Вопрос 27

Какие базы данных удовлетворяют свойствам "AP" (Availability and Partition Tolerance) из CAP-теоремы?

- [ ] PostgreSQL
- [ ] MySQL
- [x] Cassandra
- [x] HBase

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **Cassandra**:
   - Cassandra — это распределенная база данных, которая обеспечивает высокую доступность (Availability) и устойчивость к разделению сети (Partition Tolerance), но может не гарантировать строгую согласованность (Consistency) во всех случаях.

2. **HBase**:
   - HBase — это распределенная, масштабируемая база данных, которая также акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но может не гарантировать строгую согласованность (Consistency).

### Неправильные ответы

- **PostgreSQL**:
  - PostgreSQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

- **MySQL**:
  - MySQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

  Конечно, вот вопрос с использованием диаграмм, оформленный в формате Markdown:

### Вопрос 28

Какая из следующих диаграмм обычно используется для визуализации ER модели?

- [x] Диаграмма "сущность-связь"
- [ ] Алгоритм Гранта
- [ ] Круговая диаграмма
- [ ] Гистограмма

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 29

Что представляет собой ключевое понятие в логическом моделировании данных?

- [x] Сущность
- [ ] Тип данных
- [ ] Столбец таблицы
- [ ] Таблица

**Пояснение:**

- **Сущность**: В логическом моделировании данных ключевое понятие — это сущность. Сущность представляет собой объект или вещь в реальном мире, о которой необходимо хранить данные. Примеры сущностей включают клиентов, заказы, продукты и т. д.
- **Тип данных**: Это характеристика данных, которая указывает, какого рода данные могут храниться в столбце, например, строка, целое число или дата.
- **Столбец таблицы**: Это элемент структуры таблицы базы данных, который хранит данные определенного типа для всех строк таблицы.
- **Таблица**: Это структура данных в реляционной базе данных, состоящая из строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут записи.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 30

Какая нормальная форма требует, чтобы каждый атрибут был функционально зависим только от первичного ключа?

- [ ] 3NF
- [ ] 1NF
- [x] 2NF
- [ ] 4NF

**Пояснение:**

- **2NF (Вторая нормальная форма)**: Вторая нормальная форма требует, чтобы каждый атрибут был полностью функционально зависим от первичного ключа. Это означает, что таблица должна находиться в первой нормальной форме (1NF) и все неключевые атрибуты должны быть зависимы от всего первичного ключа, а не только от его части.
- **1NF (Первая нормальная форма)**: Первая нормальная форма требует, чтобы все значения атрибутов были атомарными (неделимыми), и каждый столбец содержал только одно значение.
- **3NF (Третья нормальная форма)**: Третья нормальная форма требует, чтобы таблица была в 2NF и чтобы все атрибуты были зависимы только от первичного ключа и ни от чего другого.
- **4NF (Четвертая нормальная форма)**: Четвертая нормальная форма требует, чтобы таблица находилась в 3NF и не содержала многозначных зависимостей.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 31

Какой из следующих методов является одним из основных этапов проектирования физической модели данных?

- [ ] Определение требований приложения
- [ ] Построение ER-диаграммы
- [x] Нормализация данных
- [ ] Разработка бизнес-логики

**Пояснение:**

- **Нормализация данных**: Нормализация данных — это процесс организации данных в базе данных таким образом, чтобы уменьшить избыточность и улучшить целостность данных. Это один из ключевых этапов проектирования физической модели данных, поскольку нормализация обеспечивает оптимальную структуру таблиц и связей между ними.
- **Определение требований приложения**: Это важный этап в начале проекта, связанный с анализом требований, но он относится к логическому моделированию данных.
- **Построение ER-диаграммы**: Это этап логического моделирования, который используется для визуализации структуры базы данных, но не для проектирования физической модели.
- **Разработка бизнес-логики**: Это процесс создания логики приложения, который также не относится к проектированию физической модели данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 32

Что является верным утверждением о CHECK ограничении (constraint) в базе данных?

- [ ] CHECK ограничение может быть отключено только администратором базы данных
- [ ] CHECK ограничение применяется только к числовым столбцам
- [x] CHECK ограничение проверяет удовлетворение условия
- [ ] CHECK ограничение применяется только во время вставки строки в таблицу

**Пояснение:**

- **CHECK ограничение проверяет удовлетворение условия**: CHECK ограничение применяется для проверки, удовлетворяет ли значение в столбце или столбцах определенному условию. Это может быть любое логическое выражение.
- **CHECK ограничение может быть отключено только администратором базы данных**: Это утверждение неверно, так как CHECK ограничения могут быть отключены или изменены пользователями, имеющими соответствующие права доступа.
- **CHECK ограничение применяется только к числовым столбцам**: Это утверждение неверно. CHECK ограничения могут применяться к столбцам любого типа данных.
- **CHECK ограничение применяется только во время вставки строки в таблицу**: Это утверждение неверно. CHECK ограничения применяются как при вставке, так и при обновлении строк в таблице.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 33

Связь между родительской и дочерней таблицей при использовании FOREIGN KEY устанавливается:

- [ ] По значению колонки
- [ ] По первичному ключу
- [ ] По названию колонки
- [x] По внешнему ключу

**Пояснение:**

- **По внешнему ключу**: FOREIGN KEY (внешний ключ) используется для установления связи между строками в двух таблицах. Он указывает на столбец или столбцы в одной таблице, значения которых должны соответствовать значению первичного ключа (PRIMARY KEY) в другой таблице. Это помогает поддерживать целостность данных и обеспечить корректные связи между связанными таблицами.
- **По значению колонки**: Это утверждение неверно, так как связь устанавливается не просто по значению, а через ключевую связь между таблицами.
- **По первичному ключу**: Это утверждение частично верно, так как связь через FOREIGN KEY обычно ссылается на первичный ключ другой таблицы, но основная связь все же через FOREIGN KEY.
- **По названию колонки**: Это утверждение неверно, так как связь устанавливается через ключи, а не через названия колонок.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 34

Что делает команда `ROLLBACK` в реляционной базе данных?

- [ ] Применяет изменения в текущей транзакции только для чтения, не внося их в базу данных
- [ ] Подтверждает все изменения
- [x] Отменяет все изменения, сделанные в текущей транзакции
- [ ] Удаляет все изменения из базы данных

**Пояснение:**

- **Отменяет все изменения, сделанные в текущей транзакции**: Команда `ROLLBACK` используется для отмены всех изменений, сделанных в текущей транзакции. Это позволяет вернуться к состоянию базы данных до начала транзакции.
- **Применяет изменения в текущей транзакции только для чтения, не внося их в базу данных**: Это утверждение неверно, так как `ROLLBACK` отменяет изменения, а не применяет их.
- **Подтверждает все изменения**: Это утверждение неверно. Подтверждение изменений выполняется командой `COMMIT`.
- **Удаляет все изменения из базы данных**: Это утверждение неверно, так как `ROLLBACK` отменяет изменения только в рамках текущей транзакции, но не удаляет данные из базы данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 35

Какое из следующих утверждений верно для связи "многие-ко-многим" в логической модели базы данных?

- [ ] Оно не имеет места в логической модели базы данных
- [ ] Может быть реализовано без дополнительной таблицы
- [ ] Оно всегда должно быть разрешено в логической модели базы данных
- [x] Может быть реализовано с использованием дополнительной таблицы связи

**Пояснение:**

- **Может быть реализовано с использованием дополнительной таблицы связи**: В логической модели базы данных связь "многие-ко-многим" обычно реализуется с помощью дополнительной таблицы связи (junction table или associative table). Эта таблица содержит внешние ключи, которые ссылаются на первичные ключи связанных таблиц, и служит для хранения комбинаций этих ключей.
- **Оно не имеет места в логической модели базы данных**: Это утверждение неверно, так как связи "многие-ко-многим" существуют и часто встречаются в логических моделях баз данных.
- **Может быть реализовано без дополнительной таблицы**: Это утверждение неверно, так как для реализации связи "многие-ко-многим" требуется дополнительная таблица.
- **Оно всегда должно быть разрешено в логической модели базы данных**: Это утверждение неверно, так как необходимость в таких связях определяется конкретной моделью данных и требованиями приложения.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 36

Какие из следующих операций являются следствием нарушения CHECK ограничения (constraint)?

- [ ] Автоматическое исправление нарушения
- [x] Откат транзакции
- [ ] Игнорирование нарушения
- [ ] Блокировка таблиц

**Пояснение:**

- **Откат транзакции**: Нарушение CHECK ограничения приводит к откату транзакции. Это означает, что все изменения, сделанные в рамках текущей транзакции, будут отменены, и база данных вернется к состоянию до начала транзакции.
- **Автоматическое исправление нарушения**: Это утверждение неверно. Нарушение CHECK ограничения не может быть автоматически исправлено системой.
- **Игнорирование нарушения**: Это утверждение неверно. Нарушение CHECK ограничения не может быть проигнорировано системой, так как это приведет к нарушению целостности данных.
- **Блокировка таблиц**: Это утверждение неверно. Нарушение CHECK ограничения не приводит к блокировке таблиц.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 37

Какой геометрической фигурой обозначают слабую сущность в ER модели?

- [ ] Двойным овалом
- [ ] Ромбом
- [ ] Овалом
- [x] Двойным прямоугольником

**Пояснение:**

- **Двойным прямоугольником**: В ER моделировании слабая сущность обозначается двойным прямоугольником. Слабая сущность не может быть уникально идентифицирована только своими атрибутами и зависит от связи с другой (сильной) сущностью.
- **Двойным овалом**: Это утверждение неверно. Двойной овал не используется для обозначения слабой сущности.
- **Ромбом**: Это утверждение неверно. Ромб используется для обозначения связей между сущностями.
- **Овалом**: Это утверждение неверно. Овал используется для обозначения атрибутов сущности.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 38

Какой язык программирования используется в реляционных базах данных? (Выберите все подходящие ответы)

- [x] TCL (Transaction Control Language)
- [x] DDL (Data Definition Language)
- [x] DML (Data Manipulation Language)
- [ ] GraphQL

**Пояснение:**

- **TCL (Transaction Control Language)**: TCL — это набор команд, используемых для управления транзакциями в реляционных базах данных. Команды TCL включают COMMIT, ROLLBACK и SAVEPOINT, которые используются для управления завершением и откатом транзакций.
- **DDL (Data Definition Language)**: DDL — это язык определения данных, который используется для создания и изменения структуры базы данных. Команды DDL включают CREATE, ALTER и DROP.
- **DML (Data Manipulation Language)**: DML — это язык манипуляции данными, который используется для вставки, обновления, удаления и чтения данных в базе данных. Команды DML включают INSERT, UPDATE, DELETE и SELECT.
- **GraphQL**: GraphQL — это язык запросов для API, который позволяет клиентам запрашивать только необходимые данные. Он не используется для управления реляционными базами данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 39

Какие факторы могут влиять на решение оптимизатора при выполнении запросов в реляционной базе данных? (Выберите все подходящие ответы)

- [x] Собранная статистика в базе данных
- [ ] Явное указание имен столбцов в SELECT запросе
- [x] Конфигурация реляционной базы данных
- [x] Наличие индексов в базе данных

**Пояснение:**

- **Собранная статистика в базе данных**: Оптимизатор запросов использует статистику для принятия решений о том, как лучше всего выполнить запрос. Статистика включает информацию о распределении значений, количестве строк и других характеристиках данных.
- **Явное указание имен столбцов в SELECT запросе**: Хотя это может улучшить читаемость запроса и предотвратить выбор лишних данных, это не является основным фактором, влияющим на решение оптимизатора.
- **Конфигурация реляционной базы данных**: Конфигурационные параметры базы данных, такие как размер буферного пула, настройки параллелизма и другие, могут влиять на производительность запросов и решения оптимизатора.
- **Наличие индексов в базе данных**: Индексы могут значительно ускорить выполнение запросов, и оптимизатор учитывает наличие и типы индексов при выборе плана выполнения запроса.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 40

Какие модели данных можно организовать, опираясь на реляционную модель? (Выберите все подходящие ответы)

- [ ] Иерархическая модель
- [x] Снежинка
- [x] Звезда
- [x] Data Vault

**Пояснение:**

- **Иерархическая модель**: Иерархическая модель не опирается на реляционную модель. Она организует данные в древовидной структуре, где каждая запись имеет одну родительскую и множество дочерних записей.
- **Снежинка**: Модель "Снежинка" является одной из схем многомерного моделирования данных в хранилищах данных и может быть реализована на основе реляционной модели.
- **Звезда**: Модель "Звезда" — это еще одна схема многомерного моделирования данных, широко используемая в хранилищах данных и базирующаяся на реляционной модели.
- **Data Vault**: Data Vault — это методология моделирования данных, которая также может быть реализована на основе реляционной модели. Она используется для проектирования хранилищ данных и позволяет легко добавлять и изменять данные без нарушения существующей структуры.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 41

Что означает аббревиатура ACID в контексте реляционных баз данных?

- [x] Atomicity, Consistency, Isolation, Durability
- [ ] Accuracy, Consistency, Isolation, Durability
- [ ] Atomicity, Consistency, Isolation, Data Integrity
- [ ] Availability, Consistency, Isolation, Durability

**Пояснение:**

- **Atomicity, Consistency, Isolation, Durability**: ACID — это набор свойств, который обеспечивает надежность транзакций в реляционных базах данных. Эти свойства включают:
  - **Atomicity (Атомарность)**: Гарантирует, что все операции в транзакции будут выполнены полностью или не будут выполнены вовсе.
  - **Consistency (Согласованность)**: Обеспечивает переход базы данных из одного согласованного состояния в другое согласованное состояние.
  - **Isolation (Изоляция)**: Обеспечивает независимость транзакций друг от друга, предотвращая их взаимное влияние.
  - **Durability (Долговечность)**: Обеспечивает сохранение результатов успешно завершенных транзакций даже в случае сбоя системы.
- **Accuracy, Consistency, Isolation, Durability**: Это неверный вариант, так как "Accuracy" не является частью ACID.
- **Atomicity, Consistency, Isolation, Data Integrity**: Это неверный вариант, так как "Data Integrity" не является частью ACID.
- **Availability, Consistency, Isolation, Durability**: Это неверный вариант, так как "Availability" не является частью ACID.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 42

Какое свойство CAP-теоремы предполагает, что распределенная система продолжит функционировать даже в случае аварии некоторых узлов?

- [ ] C + A (Consistency + Availability)
- [ ] C (Consistency)
- [ ] A (Availability)
- [x] P (Partition Tolerance)

**Пояснение:**

- **P (Partition Tolerance)**: Partition Tolerance (устойчивость к разделению) — это свойство, которое обеспечивает способность распределенной системы продолжать работу, даже если в сети возникают разделения (сбой связи между узлами). Это означает, что система сможет функционировать и обрабатывать запросы, несмотря на потерю связи между некоторыми узлами.
- **C + A (Consistency + Availability)**: Это неверный вариант, так как C + A не является одним из свойств CAP-теоремы.
- **C (Consistency)**: Consistency (согласованность) означает, что все узлы в системе видят одни и те же данные в одно и то же время. Это не связано с устойчивостью к разделению.
- **A (Availability)**: Availability (доступность) означает, что каждый запрос, полученный системой, получает ответ (успешный или неуспешный) в течение разумного времени. Это не связано с устойчивостью к разделению.

[↑ Вернуться к оглавлению](#оглавление)


Вот вопрос и варианты ответов, оформленные в формате Markdown:

### Вопрос 43
Какой из следующих типов CHECK CONSTRAINT позволяет проверить, что значение в столбце находится в определенных границах?

- **CHECK на основе условных выражений**  
  *Позволяет проверять условия, но не специально ориентирован на границы значений.*

- **CHECK на основе функции**  
  *Позволяет использовать пользовательские функции для проверки данных, но не специфичен для диапазонов.*

- **CHECK на основе диапазона значения**  
  *Позволяет задавать прямые ограничения на значения в пределах определенного диапазона.*

- **CHECK на основе подзапроса**  
  *Использует результаты подзапросов для проверки условий, что может включать диапазоны, но не ограничивается ими.*

### Правильный ответ:

**CHECK на основе диапазона значения**  
*Этот тип CHECK CONSTRAINT является наиболее подходящим для проверки, что значение в столбце находится внутри заданных границ. Он позволяет напрямую указывать верхние и нижние границы для значений в столбце, такие как `CHECK (age BETWEEN 18 AND 65)`, гарантируя, что значения в столбце соответствуют этому диапазону.*

--- 

### Вопрос: 44 
### Как удалить CHECK CONSTRAINT из таблицы с использованием DDL?

- **DROP**  
  *Обычно используется для удаления таблиц или баз данных, а не конкретных ограничений.*

- **DELETE**  
  *Используется для удаления записей из таблицы, а не для удаления ограничений.*

- **REMOVE**  
  *Не является командой DDL в SQL.*

- **ALTER**  
  *Используется для изменения структуры таблицы, включая удаление ограничений.*

### Правильный ответ:

**ALTER**  
*Чтобы удалить CHECK CONSTRAINT из таблицы, используется команда ALTER TABLE. Например, если ограничение называется `chk_age`, и оно находится в таблице `person`, то команда для его удаления будет выглядеть так: `ALTER TABLE person DROP CONSTRAINT chk_age;` Это изменит структуру таблицы, удалив указанное ограничение.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос: 45
### Какое предназначение уровня изоляции транзакции в реляционной базе данных?

- **Определять, какие транзакции должны быть выполнены первыми**  
  *Это утверждение неверно, так как уровень изоляции не определяет порядок выполнения транзакций.*

- **Определять, какие операции могут выполниться в рамках одной транзакции**  
  *Это утверждение неверно, так как уровень изоляции не определяет набор операций, которые могут быть выполнены в транзакции.*

- **Определять, какие данные можно изменить из базы данных**  
  *Это утверждение неверно, так как уровень изоляции не определяет, какие данные могут быть изменены.*

- **Устанавливать правила согласованности данных во время параллельного доступа к базе данных**  
  *Это утверждение верно, так как уровень изоляции определяет, как транзакции видят данные, измененные другими транзакциями, и как они предотвращают возможные проблемы, такие как грязное чтение, повторяемые чтения и фантомные чтения.*

### Правильный ответ:

**Устанавливать правила согласованности данных во время параллельного доступа к базе данных**  
*Уровень изоляции транзакции определяет, насколько одна транзакция изолирована от других транзакций. Вышеуказанный уровень изоляции устанавливает правила для обеспечения данных и их согласованности при параллельном доступе к базе данных.*

[↑ Вернуться к оглавлению](#оглавление)

---


### Вопрос: 46
### Какая нормальная форма устраняет транзитивные зависимости данных во время функциональной зависимости?

- **2NF (Вторая нормальная форма)**  
  *Устраняет частичные зависимости, когда неключевые атрибуты зависят только от части составного первичного ключа.*

- **3NF (Третья нормальная форма)**  
  *Устраняет транзитивные зависимости, когда неключевые атрибуты зависят от других неключевых атрибутов.*

- **4NF (Четвертая нормальная форма)**  
  *Рассматривает проблемы многозначных зависимостей, а не транзитивных зависимостей.*

- **5NF (Пятая нормальная форма)**  
  *Рассматривает случаи, когда данные могут быть воссозданы из нескольких таблиц с помощью соединений без потери информации, но это не связано с транзитивными зависимостями.*

### Правильный ответ:

**3NF (Третья нормальная форма)**  
*Третья нормальная форма (3NF) является той, которая устраняет транзитивные зависимости в базе данных. Это достигается путем гарантии того, что каждый неключевой атрибут функционально зависит только от первичных ключей.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос: 47
### Что представляет собой внешний ключ в физической базе данных?

- **Столбцы информацию о типах данных**  
  *Это утверждение неверно, так как внешний ключ не содержит информацию о типах данных.*

- **Столбцы только уникальные значения**  
  *Это утверждение неверно, так как внешний ключ может содержать повторяющиеся значения, соответствующие значениям в первичном ключе родительской таблицы.*

- **Уникальная идентификация для запоминания в родительской таблице**  
  *Это утверждение неверно, так как внешний ключ не обязательно уникален сам по себе. Он служит для ссылки на первичный ключ родительской таблицы.*

- **Столбцы дублирующие значения**  
  *Это утверждение верно, так как внешний ключ представляет собой один или несколько столбцов в таблице, которые используются для хранения значений, обычно соответствующих первичному ключу в другой (родительской) таблице, и могут повторяться в зависимой таблице.*

### Правильный ответ:

**Столбцы дублирующие значения**  
*Внешний ключ в физической базе данных представляет собой столбцы, которые могут содержать дублирующие значения, отражающие первичный ключ в родительской таблице. Это позволяет устанавливать и поддерживать связи между таблицами, обеспечивая ссылочную целостность данных.*

[↑ Вернуться к оглавлению](#оглавление)


---

### Вопрос: 48
### Какой тип связи могут осуществлять в логической модели данных?

- **Одно-ко-многим**  
  *Этот тип связи означает, что одна запись в одной таблице может быть связана с множеством записей в другой таблице. Это один из самых распространенных типов связей в реляционных базах данных.*

- **Одно-ко-одному**  
  *Этот тип связи означает, что одна запись в одной таблице связана только с одной записью в другой таблице. Это более редкий тип связи, который может использоваться для разделения таблицы на две части по причинам оптимизации или безопасности.*

- **Многие-ко-многим**  
  *Этот тип связи означает, что множество записей в одной таблице могут быть связаны с множеством записей в другой таблице. Обычно реализуется с помощью третьей таблицы, которая называется таблицей связей или ассоциативной таблицей.*

- **Гибридная связь**  
  *Этот термин не является стандартным в контексте типов связей в реляционных базах данных. Не существует определенного типа связи, называемого "гибридной связью" в стандартных моделях данных.*

### Правильный ответ:

- **Одно-ко-многим**
- **Одно-ко-одному**
- **Многие-ко-многим**

*Все перечисленные типы связей (кроме гибридной связи) являются стандартными и широко используются в логическом моделировании данных. Они позволяют организовывать данные таким образом, чтобы эффективно управлять связями между сущностями в базе данных.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос: 49
### Какая DDL команда переименовывает индекс в реляционной базе данных?

- **modify index rename**  
  *Это утверждение неверно, так как нет стандартной DDL команды с таким синтаксисом.*

- **rename index**  
  *Это утверждение неверно, так как `RENAME INDEX` не является стандартной DDL командой.*

- **change index name**  
  *Это утверждение неверно, так как `CHANGE INDEX NAME` не является стандартной DDL командой.*

- **alter index rename**  
  *Это утверждение верно для некоторых систем управления базами данных. Однако, точный синтаксис может варьироваться в зависимости от СУБД. Например, в PostgreSQL используется `ALTER INDEX [старое имя] RENAME TO [новое имя]`.*

### Правильный ответ:

**alter index rename**  
*Команда `ALTER INDEX` с ключевым словом `RENAME` используется для переименования индекса в некоторых реляционных базах данных. Однако точный синтаксис может отличаться в разных СУБД. Важно проверить документацию конкретной базы данных для правильного использования этой команды.*

[↑ Вернуться к оглавлению](#оглавление)


---

### Вопрос: 50
### Какой характеристикой обладает нормальная форма Бойса-Кодда (BCNF) в реляционном дизайне баз данных?

- **Устранение транзитивной функциональной зависимости**  
  *Это утверждение неверно, так как устранение транзитивной зависимости является целью третьей нормальной формы (3NF), а не BCNF.*

- **Устранение всех аномалий вставки, обновлений и удалений в базе данных**  
  *Это утверждение частично верно, так как BCNF целится в устранение аномалий, связанных с функциональными зависимостями, но полностью избавиться от всех аномалий может быть сложно даже с BCNF.*

- **Гарантирует отсутствие множественных зависимостей**  
  *Это утверждение неверно, так как гарантия отсутствия множественных зависимостей является задачей четвертой нормальной формы (4NF).*

- **Все атрибуты зависят только от первичного ключа**  
  *Это утверждение верно и является основным принципом BCNF. В нормальной форме Бойса-Кодда каждый атрибут должен зависеть только от "суперключа", что является усилением требований 3NF.*

### Правильный ответ:

**Все атрибуты зависят только от первичного ключа**  
*BCNF устраняет аномалии, возникающие когда таблица находится в 3NF, но все же содержит зависимости, при которых неключевые атрибуты зависят от части составного ключа. BCNF требует, чтобы каждый атрибут был функционально зависим только от "суперключей", что предотвращает зависимости атрибутов от неполных ключей.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос: 51
### Что произойдет при попытке удаления записи из родительской таблицы, если существует связь в дочерней таблице с установленным foreign key и выставлена политика `RESTRICT`?

- **Все дочерние записи будут удалены, но родительская нет**  
  *Это утверждение неверно, так как политика `RESTRICT` не позволяет удалять родительскую запись, если существуют связанные дочерние записи.*

- **Возникнет ошибка**  
  *Это утверждение верно, так как при попытке удалить родительскую запись, когда существуют зависимые дочерние записи и настроена политика `RESTRICT`, система управления базами данных выдаст ошибку.*

- **Удаление дочерних и родительских строк будет выполнено без предупреждения**  
  *Это утверждение неверно, так как политика `RESTRICT` как раз предотвращает удаление, если существуют зависимости.*

- **Удаление будет отклонено**  
  *Это утверждение верно, так как политика `RESTRICT` предотвращает удаление родительской записи, если на неё ссылаются дочерние записи, отклоняя операцию удаления.*

### Правильный ответ:

**Возникнет ошибка** и **Удаление будет отклонено**  
*При попытке удаления записи из родительской таблицы с установленной политикой `RESTRICT` на foreign key, операция будет отклонена с выдачей ошибки, так как существуют зависимые дочерние записи. Это гарантирует, что никакие дочерние записи не останутся "висеть" без связанной родительской записи.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 52
### Что в большей степени характеризует нереляционные базы данных?

- **Транзакционная поддержка**  
  *Хотя некоторые нереляционные базы данных могут поддерживать транзакции, это не является их характерной чертой, особенно по сравнению с реляционными базами данных.*

- **Строгая схема данных**  
  *Это утверждение характерно скорее для реляционных баз данных, которые требуют строгого определения структуры таблиц и связей.*

- **Использование SQL для запросов**  
  *Это также характеризует реляционные базы данных. Нереляционные базы данных часто используют другие методы запросов, не основанные на SQL.*

- **Гибкая схема данных**  
  *Это одна из ключевых особенностей нереляционных баз данных. Они позволяют работать с данными, структура которых может изменяться без необходимости перестроения всей базы данных.*

### Правильный ответ:

**Гибкая схема данных**  
*Гибкая схема данных является определяющей характеристикой нереляционных баз данных. Это позволяет им быстро адаптироваться к изменяющимся требованиям к данным и обеспечивать более гибкое хранение и обработку данных по сравнению с реляционными базами данных, что делает их идеальными для больших объемов структурированных и неструктурированных данных.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 53 
### Какой компонент отвечает за выполнение запроса и при этом старается обеспечить его оптимальное исполнение?

- **Storage engine**  
  *Этот компонент отвечает за хранение и извлечение данных в базе данных, но не прямо за оптимизацию выполнения запросов.*

- **Backup service**  
  *Этот компонент отвечает за резервное копирование данных и не участвует в оптимизации запросов.*

- **Query optimizer**  
  *Это правильный ответ. Запросный оптимизатор (query optimizer) — это часть системы управления базами данных, которая анализирует SQL-запросы и определяет наиболее эффективный способ их выполнения.*

- **DML (Data Manipulation Language)**  
  *DML относится к языку манипулирования данными, включая команды вроде `INSERT`, `UPDATE`, `DELETE`, и `SELECT`. Это не компонент, а часть SQL, используемая для выполнения операций с данными.*

### Правильный ответ:

**Query optimizer**  
*Query optimizer или запросный оптимизатор — это компонент системы управления базой данных, который анализирует различные возможные пути выполнения запроса и выбирает наиболее эффективный. Это критически важно для повышения производительности базы данных, особенно в условиях больших объемов данных и сложных запросов.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 54
### Какие действия можно предпринять для оптимизации работы реляционной базы данных?

- **Проанализировать и провести денормализацию модели данных**  
  *Это верный ответ. Денормализация может улучшить производительность за счет сокращения количества необходимых соединений (joins) и увеличения скорости чтения данных.*

- **Увеличить размер выделения памяти для базы данных**  
  *Это утверждение может быть верным в некоторых контекстах, но оно касается увеличения производительности через аппаратные ресурсы, а не оптимизации работы базы данных на уровне данных или запросов.*

- **Пересобрать статистику по таблицам базы данных**  
  *Это верный ответ. Статистика базы данных используется оптимизатором запросов для выбора наилучших планов выполнения запросов. Актуальные данные статистики позволяют оптимизатору делать лучший выбор.*

- **Обновить индексы к таблицам**  
  *Это также верный ответ. Обслуживание индексов, включая их реконструкцию и реорганизацию, может значительно улучшить время ответа на запросы, особенно в базах данных с большим объемом операций вставки, обновления или удаления данных.*

### Правильный ответ:

Все предложенные меры, кроме увеличения размера выделения памяти, могут быть эффективны для оптимизации работы реляционной базы данных:
- **Проанализировать и провести денормализацию модели данных**
- **Пересобрать статистику по таблицам базы данных**
- **Обновить индексы к таблицам**

Эти действия направлены на улучшение структуры данных и эффективности выполнения запросов, что может существенно повысить производительность базы данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 55 
### Какой аспект теоремы CAP утверждает, что каждый запрос к системе должен получить ответ?

Теорема CAP (Consistency, Availability, Partition tolerance) говорит о трех ключевых свойствах распределённых систем. Вот как они определяются:

- **C (Consistency)**  
  *Согласованность означает, что все узлы видят одни и те же данные в одно и то же время. Не гарантирует, что каждый запрос получит ответ.*

- **A (Availability)**  
  *Доступность означает, что каждый запрос получает ответ о успехе или неудаче операции, независимо от состояния одного или нескольких узлов.*

- **P (Partition tolerance)**  
  *Устойчивость к разделению гарантирует, что система продолжит работу, даже если часть узлов выйдет из строя или будет отсечена от остальной части системы.*

### Правильный ответ:

**A (Availability)**  
*Аспект доступности (Availability) теоремы CAP утверждает, что каждый запрос к системе должен получить ответ, независимо от того, успешен ли он или нет. Это означает, что система всегда реагирует на запросы, делая доступность ключевым аспектом для приложений, которые не могут терпеть отказ в обработке запросов.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 56 
### Какой принцип ACID гарантирует, что транзакция будет выполнена либо полностью, либо не выполнена вовсе?

Принципы ACID описывают ключевые характеристики, которыми должны обладать транзакции в базах данных для обеспечения надежности. Вот что означает каждая буква в аббревиатуре ACID:

- **A (Atomicity)**  
  *Атомарность гарантирует, что транзакция будет выполнена полностью или не будет выполнена вовсе. Если какая-либо часть транзакции не может быть завершена, вся транзакция откатывается (отменяется).*

- **C (Consistency)**  
  *Согласованность обеспечивает, что транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние, сохраняя все правила базы данных.*

- **I (Isolation)**  
  *Изоляция обеспечивает, что транзакции, выполняющиеся одновременно, не влияют друг на друга.*

- **D (Durability)**  
  *Долговечность гарантирует, что после завершения транзакции ее результаты сохраняются и не могут быть потеряны даже в случае сбоев системы.*

### Правильный ответ:

**A (Atomicity)**  
*Атомарность (Atomicity) гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена вовсе. Это означает, что если транзакция не может быть завершена по любой причине, все ее частичные изменения будут отменены, чтобы база данных не содержала неполных данных.*

[↑ Вернуться к оглавлению](#оглавление)

## Вопросы с таблицами и запросами

### Вопрос 57

Что вернет следующий SQL-запрос?

```sql
SELECT CASE 
           WHEN NULL = 5 THEN 'a' 
           WHEN NULL <> 5 THEN 'b' 
           ELSE 'c' 
       END AS result;
```

- [ ] 'a'
- [ ] 'b'
- [x] 'c'
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **'c'**:
  - В SQL любое сравнение с `NULL` всегда возвращает `NULL`. Таким образом, условия `WHEN NULL = 5` и `WHEN NULL <> 5` не выполнятся, и будет возвращено значение из блока `ELSE`, то есть 'c'.

---

### Вопрос 58

Что делает следующий SQL-запрос?

```sql
SELECT SUM(t1.value) 
FROM (SELECT NULL::integer AS value) AS t1;
```

- [ ] Возвращает 0
- [x] Возвращает NULL
- [ ] Возвращает ошибку
- [ ] Возвращает 1

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Возвращает NULL**:
  - Функция `SUM` игнорирует значения `NULL`, но если все значения, которые нужно суммировать, являются `NULL`, результат будет `NULL`.

---

### Вопрос 59

Что вернет следующий SQL-запрос?

```sql
SELECT 1 + 1 AS value 
WHERE 1 = 1 AND 1 = 2;
```

- [ ] 2
- [ ] 1
- [ ] 0
- [x] Ничего (пустой результат)

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ничего (пустой результат)**:
  - Условие `WHERE 1 = 1 AND 1 = 2` всегда ложно, поэтому запрос не вернет ни одной строки.

---
### Вопрос 60

Что вернет следующий SQL-запрос в PostgreSQL?

```sql
SELECT 'Привет' || NULL || 'друзья!' AS result;
```

- [ ] Привет NULL друзья!
- [ ] NULL
- [ ] Привет друзья!
- [x] NULL друзья!

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **NULL**:
  - В PostgreSQL оператор конкатенации `||` возвращает `NULL`, если любой из его операндов равен `NULL`. Таким образом, результатом данного запроса будет `NULL`.

---

### Вопрос 61

Что делает следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE EXISTS (
    SELECT NULL 
    FROM hobby AS h 
    WHERE h.student_id = s.student_id
);
```

- [x] Считает количество студентов, у которых есть хотя бы одно хобби
- [ ] Считает количество студентов, у которых нет хобби
- [ ] Возвращает количество всех записей в таблице `hobby`
- [ ] Возвращает количество всех записей в таблице `student`

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Считает количество студентов, у которых есть хотя бы одно хобби**:
  - Подзапрос проверяет существование записи в таблице `hobby`, связанной со студентом из таблицы `student`. `COUNT(*)` возвращает количество таких студентов.

---

### Вопрос 62


Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT DISTINCT employee AS emp 
FROM employee 
WHERE transaction BETWEEN 50 AND 300 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван
- [x] Анна
- [ ] Ирина
- [ ] NULL

**Пояснение:**

- **Анна**: Запрос выбирает уникальные значения `employee`, у которых `transaction` находится в диапазоне от 50 до 300 включительно. Затем результат сортируется по имени `employee`, и выбирается первая строка. Анна будет первой в отсортированном списке.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 63

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT string_agg(t1.id::VARCHAR, ',' ORDER BY t1.id) AS result 
FROM (
    SELECT s.id 
    FROM student AS s 
    UNION ALL 
    SELECT h.student_id 
    FROM hobby AS h
) AS t1;
```

- [x] 1,1,1,2,3,3,4
- [ ] 1,1,2,3,3,4
- [ ] Ошибка
- [ ] 1,2,3,3

**Пояснение:**

- **1,1,1,2,3,3,4**: Запрос объединяет все `id` из таблицы `student` и `student_id` из таблицы `hobby` с использованием `UNION ALL`, что сохраняет все дубликаты. Затем `string_agg` объединяет эти значения в строку, разделяя их запятыми, и сортирует по `id`.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 64

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    RIGHT JOIN hobby AS h 
    ON s.id = h.student_id 
    ORDER BY s.name NULLS FIRST 
    LIMIT 1
), 
_b AS (
    SELECT 1/0 AS res
) 
SELECT * 
FROM _a 
INNER JOIN _b;
```

- [x] Синтаксическая ошибка
- [ ] Иван, Музыка
- [ ] NULL, Плавание
- [ ] Анна, NULL

**Пояснение:**

- **Синтаксическая ошибка**: Этот вариант верен, так как попытка выполнения запроса с делением на ноль (`SELECT 1/0 AS res`) приведет к ошибке выполнения.
- **Иван, Музыка**: Этот вариант неверен, так как запрос будет прерван ошибкой деления на ноль.
- **NULL, Плавание**: Этот вариант неверен, так как запрос будет прерван ошибкой деления на ноль.
- **Анна, NULL**: Этот вариант неверен, так как запрос будет прерван ошибкой деления на ноль.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 65

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT NULL 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [ ] 1
- [x] 1
- [ ] 2
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос выбирает количество студентов, у которых нет соответствующих записей в таблице `hobby`. В данном случае, студент с `id = 2` (Анна) не имеет записей в таблице `hobby`, поэтому результатом будет `1`.

---

### Вопрос 66

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE id NOT IN (
    SELECT student_id 
    FROM hobby 
    WHERE hobby ILIKE '%Хоккей%'
);
```

- [ ] 1
- [ ] 2
- [x] 2
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **2**:
  - Запрос выбирает количество студентов, у которых нет хобби, содержащего слово "Хоккей". В данном случае, только у студента с `id = 1` (Иван) есть хобби "Хоккей". Поэтому студенты с `id = 2` (Анна) и `id = 3` (Ирина) будут включены в результат, что дает итоговый счет 2.
  `ILIKE` используется в PostgreSQL для нечувствительного к регистру поиска по шаблону. 
---

### Вопрос 67

Имеется следующая таблица `student`:

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

Что вернет следующий SQL-запрос?

```sql
SELECT reg_num 
FROM student 
ORDER BY reg_num NULLS LAST 
LIMIT 1;
```

- [ ] 123
- [ ] 456
- [ ] NULL
- [x] 123

### Пояснение к правильному ответу

- **123**:
  - Запрос выбирает значения столбца `reg_num` из таблицы `student`, сортируя их по возрастанию с размещением значений `NULL` в конце (`NULLS LAST`), и ограничивает результат одной строкой (`LIMIT 1`). Поскольку 123 является наименьшим ненулевым значением, оно будет первым в отсортированном списке, и результатом будет 123.

---
### Вопрос 68

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
CROSS JOIN hobby AS h 
ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван, Музыка
- [ ] Анна, Хоккей
- [ ] Ирина, Плавание
- [x] Иван, Хоккей

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван, Хоккей**:
  - Запрос выполняет `CROSS JOIN` (в данном случае это синтаксическая ошибка, так как для `CROSS JOIN` не требуется условие `ON`) между таблицами `student` и `hobby`, и затем фильтрует результаты, чтобы включить только те строки, где хобби равно 'Хоккей' или 'Чтение'. Поскольку значение 'Хоккей' связано со студентом Иван, и 'Чтение' связано со студенткой Ириной, после сортировки по имени и ограничения одной строкой, результатом будет Иван, Хоккей.

### Уточнение по синтаксису запроса

Запрос должен использовать `INNER JOIN` или `JOIN`, так как `CROSS JOIN` не требует условия `ON`.

Исправленный запрос:

```sql
SELECT s.name, h.hobby 
FROM student AS s 
JOIN hobby AS h 
ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Иван | Хоккей |

---

### Вопрос 69

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    LEFT JOIN hobby AS h 
    ON s.id = h.student_id
)
SELECT * 
FROM _a 
ORDER BY name NULLS FIRST 
LIMIT 1;
```

- [ ] Анна, NULL
- [ ] Иван, Хоккей
- [x] Анна, NULL
- [ ] Ирина, Чтение

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Анна, NULL**:
  - Запрос использует CTE (`WITH _a AS ...`), который выполняет левое соединение (`LEFT JOIN`) таблиц `student` и `hobby` по условию `s.id = h.student_id`. Затем основной запрос выбирает все строки из CTE `_a`, сортирует их по имени, помещая значения `NULL` в начало (`NULLS FIRST`), и ограничивает результат одной строкой (`LIMIT 1`). Поскольку Анна не имеет записи в таблице `hobby`, результат будет `Анна, NULL`.


---

### Вопрос 70

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT (2 + 2 * 2) 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [ ] 1
- [ ] 2
- [x] 1
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос выбирает количество студентов, у которых нет соответствующих записей в таблице `hobby`. В данном случае, студент с `id = 2` (Анна) не имеет записей в таблице `hobby`, поэтому результатом будет `1`.


### Вопрос 71

Имеется следующая таблица `student`:

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

Что вернет следующий SQL-запрос?

```sql
SELECT reg_num 
FROM student 
ORDER BY CASE 
            WHEN reg_num IS NULL THEN 1 
            ELSE reg_num 
         END 
LIMIT 1;
```

- [ ] 123
- [ ] 456
- [x] 1
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос сортирует таблицу `student` по `reg_num`, используя конструкцию `CASE WHEN reg_num IS NULL THEN 1 ELSE reg_num END`. Это приводит к тому, что значения `NULL` обрабатываются как 1. После сортировки результаты ограничиваются одной строкой (`LIMIT 1`). Поскольку строка с `reg_num` равным `NULL` будет заменена на 1 в сортировке, она будет первой в списке. 

---

### Вопрос 72

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT employee, SUM(transaction) 
FROM employee 
GROUP BY employee 
HAVING MIN(transaction) = MAX(transaction) 
ORDER BY employee 
LIMIT 1;
```

- [ ] Иван, 430
- [ ] Анна, 245
- [x] Ирина, 50
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ирина, 50**:
  - Запрос группирует строки по столбцу `employee`, а затем применяет условие `HAVING MIN(transaction) = MAX(transaction)`, чтобы выбрать только тех сотрудников, у которых все значения `transaction` одинаковы. В данном случае это применимо только к Ирине, так как у неё одна транзакция равна 50. Запрос затем суммирует транзакции для каждого сотрудника, сортирует результат по имени и ограничивает результат одной строкой (`LIMIT 1`). Иван и Анна имеют разные значения транзакций, поэтому они не будут включены в результат.

---

### Вопрос 73

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT employee 
FROM (
    SELECT employee, 
           ROW_NUMBER() OVER (ORDER BY transaction) AS row_num 
    FROM employee 
    GROUP BY employee
) AS t1 
WHERE t1.row_num != 2 
ORDER BY employee DESC 
LIMIT 1;
```

- [ ] Иван
- [ ] Анна
- [x] Ирина
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ирина**:
  - Запрос использует оконную функцию `ROW_NUMBER()` для нумерации строк на основе значения `transaction`, группирует данные по `employee`. Затем внешний запрос выбирает всех сотрудников, у которых `row_num` не равно 2, сортирует результат по имени сотрудника в порядке убывания и ограничивает результат одной строкой (`LIMIT 1`). Поскольку `ROW_NUMBER()` присваивает номера строкам на основе значения `transaction`, и учитывая, что у нас только три уникальных имени, результатом будет Ирина, так как у неё наименьшее значение `transaction`.

---

### Вопрос 74

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
NATURAL JOIN hobby AS h 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван, Музыка
- [ ] Анна, Хоккей
- [ ] Ирина, Плавание
- [x] Иван, Хоккей

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван, Хоккей**:
  - Запрос выполняет `NATURAL JOIN` между таблицами `student` и `hobby`, что автоматически объединяет строки по общему столбцу, которым в данном случае является `id` в таблице `student` и `student_id` в таблице `hobby`. Затем фильтруются результаты, чтобы включить только те строки, где хобби равно 'Хоккей' или 'Чтение'. Поскольку значение 'Хоккей' связано со студентом Иван, и 'Чтение' связано со студенткой Ириной, после сортировки по имени и ограничения одной строкой, результатом будет Иван, Хоккей.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Иван | Хоккей |

---
### Вопрос 75

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT string_agg(t1.student_id::VARCHAR, ',' ORDER BY t1.student_id) AS result 
FROM (
    SELECT s.id 
    FROM student AS s 
    INTERSECT 
    SELECT h.student_id 
    FROM hobby AS h
) AS t1;
```

- [ ] 1,2,3
- [ ] 10,20,30,40
- [x] 1,3
- [ ] 1,1,3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1,3**:
  - Запрос выполняет пересечение (`INTERSECT`) между `id` из таблицы `student` и `student_id` из таблицы `hobby`, чтобы найти общие значения. Затем функция `string_agg` объединяет эти значения в строку, разделяя их запятыми, и сортирует их по `student_id`. В данном случае студентами, имеющими записи как в таблице `student`, так и в таблице `hobby`, являются студенты с `id = 1` и `id = 3`.


### Вопрос 76


### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |


Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE EXISTS (
    SELECT 0 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [x] 2
- [ ] Данный запрос не вернет ни одной строки
- [ ] 3
- [ ] 0

**Пояснение:**

- **2**: Запрос подсчитывает количество записей в таблице `student`, для которых существует хотя бы одна соответствующая запись в таблице `hobby`. В данном случае, только для двух студентов (`id = 1` и `id = 3`) существуют соответствующие записи в таблице `hobby`, поэтому результатом будет 2.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 77

Имеется следующая таблица `hobby`:

#### Таблица `hobby`
| id | student | hobby   |
|----|---------|---------|
| 1  | Иван    | Хоккей  |
| 2  | Анна    | Блог    |
| 3  | Ирина   | Чтение  |
| 4  | Иван    | Футбол  |
| 5  | Анна    | Спорт   |

Что вернет следующий SQL-запрос?

```sql
SELECT student 
FROM hobby 
GROUP BY student 
HAVING student LIKE '%Анна%' AND id = 2 
LIMIT 1;
```

- [ ] Анна
- [x] Синтаксическая ошибка
- [ ] Ни одна строка
- [ ] NULL

**Пояснение:**

- **Анна**: Этот вариант неверен, так как условие `HAVING student LIKE '%Анна%' AND id = 2` неверно.
- **Синтаксическая ошибка**: Этот вариант верен, так как в запросе есть синтаксическая ошибка — использование `id` в условиях `HAVING`, где оно не группируется.
- **Ни одна строка**: Этот вариант неверен, так как синтаксическая ошибка не позволяет запросу выполниться.
- **NULL**: Этот вариант неверен, так как запрос не выполнится из-за синтаксической ошибки.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 78

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT * 
FROM student AS s 
NATURAL JOIN hobby AS h;
```

- [ ] r = 3, c = 4
- [ ] r = 4, c = 4
- [x] r = 2, c = 4
- [ ] r = 14, c = 4

**Пояснение:**

- **r = 3, c = 4**: Этот вариант неверен, так как результат запроса будет содержать только строки, которые соответствуют объединению (join) по общим столбцам (в данном случае `id` и `student_id`), и таких строк будет 2.
- **r = 4, c = 4**: Этот вариант неверен, так как результат запроса будет содержать меньше строк.
- **r = 2, c = 4**: Этот вариант верен, так как результат запроса будет содержать 2 строки и 4 столбца (id, name, student_id, hobby).
- **r = 14, c = 4**: Этот вариант неверен, так как результат запроса не может содержать столько строк.

**Проверка данных:**

Объединенные строки:
1. Иван - Хоккей
2. Иван - Музыка

Таким образом, при NATURAL JOIN строки будут объединены по `id` и `student_id`, и результат будет включать только 2 строки.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 79

Что вернет следующий SQL-запрос?

```sql
SELECT MIN(t1.value) 
FROM (SELECT NULL::Integer AS value) AS t1;
```

- [x] NULL
- [ ] Синтаксическая ошибка
- [ ] 1
- [ ] 0

**Пояснение:**

- **NULL**: Этот вариант верен, так как запрос выбирает минимальное значение из единственной строки, где `value` имеет значение `NULL`. Функция `MIN` при работе с единственным значением `NULL` вернет `NULL`.
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.
- **1**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 1.
- **0**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 0.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 80

Что вернет следующий SQL-запрос?

```sql
SELECT 1+1 AS value 
WHERE 1=1;
```

- [ ] Синтаксическая ошибка
- [ ] Ни одной строки
- [ ] NULL
- [x] 2

**Пояснение:**

- **2**: Этот вариант верен, так как условие `WHERE 1=1` всегда истинно. Запрос выполнится и вернет результат 1+1, который равен 2.
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.
- **Ни одной строки**: Этот вариант неверен, так как условие `WHERE 1=1` всегда истинно, и запрос вернет одну строку с результатом 2.
- **NULL**: Этот вариант неверен, так как запрос вернет результат вычисления 1+1, который равен 2.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 81

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
FULL JOIN hobby AS h 
ON s.id = h.student_id 
ORDER BY h.hobby NULLS LAST;
```

- [ ] Анна, NULL
- [ ] Иван, Музыка
- [ ] Ни одной строки
- [x] NULL, Плавание

**Пояснение:**

- **Анна, NULL**: Этот вариант неверен, так как Анна имеет соответствующую запись в таблице `hobby` (Плавание).
- **Иван, Музыка**: Этот вариант неверен, так как при сортировке `NULL` значений они будут размещены последними.
- **Ни одной строки**: Этот вариант неверен, так как результат запроса будет содержать строки.
- **NULL, Плавание**: Этот вариант верен, так как `FULL JOIN` объединяет все записи из обеих таблиц, включая строки, не имеющие соответствия. При сортировке по `hobby` с `NULLS LAST`, строки с `NULL` в столбце `hobby` будут последними. Таким образом, последняя строка будет иметь `NULL` в `name` и `Плавание` в `hobby`.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 82
Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
FULL JOIN hobby AS h 
ON s.id = h.student_id 
ORDER BY h.hobby NULLS LAST 
LIMIT 1;
```

- [ ] Анна, NULL
- [ ] Иван, Музыка
- [ ] Ни одной строки
- [x] Иван, Музыка

**Пояснение:**

Запрос выполняет `FULL JOIN`, который объединяет строки из обеих таблиц, даже если в одной из таблиц нет соответствующих строк. После этого происходит сортировка по столбцу `hobby`, при этом `NULL` значения перемещаются в конец. Поскольку используется `LIMIT 1`, вернется первая строка после сортировки.

Результат сортировки:
| name | hobby   |
|------|---------|
| Иван | Музыка  |
| Иван | Хоккей  |
| Ирина| Чтение  |
| NULL | Плавание|
| Анна | NULL    |

Так как используется `LIMIT 1`, возвращается первая строка:
- **Иван, Музыка**

### Ответ:
- [x] Иван, Музыка

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 83

Что вернет следующий SQL-запрос?

```sql
SELECT MAX(t1.value) 
FROM (SELECT NULL::integer AS value) AS t1;
```

- [ ] 0
- [x] NULL
- [ ] 1
- [ ] Синтаксическая ошибка

**Пояснение:**

- **NULL**: Этот вариант верен, так как запрос выбирает максимальное значение из единственной строки, где `value` имеет значение `NULL`. Функция `MAX` при работе с единственным значением `NULL` вернет `NULL`.
- **0**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 0.
- **1**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 1.
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 84

Что вернет следующий SQL-запрос?

```sql
SELECT 1+1 AS value 
WHERE 1=1 AND NOT (SELECT true);
```

- [x] Синтаксическая ошибка
- [ ] Ни одной строки
- [ ] 2
- [ ] NULL

**Пояснение:**

- **Синтаксическая ошибка**: Этот вариант верен. Подзапрос в условии `WHERE` должен возвращать скалярное значение (одно значение). Однако выражение `SELECT true` возвращает результат в виде множества, что вызывает синтаксическую ошибку.
- **Ни одной строки**: Этот вариант неверен, так как запрос синтаксически некорректен и не будет выполнен.
- **2**: Этот вариант неверен, так как запрос синтаксически некорректен и не будет выполнен.
- **NULL**: Этот вариант неверен, так как запрос синтаксически некорректен и не будет выполнен.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 85

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE id IN (
    SELECT student_id 
    FROM hobby 
    WHERE hobby LIKE '%Хоккей%'
);
```

- [ ] NULL
- [ ] Ни одной строки
- [ ] 3
- [x] 1

**Пояснение:**

- **NULL**: Этот вариант неверен, так как запрос возвращает количество строк.
- **Ни одной строки**: Этот вариант неверен, так как запрос возвращает количество строк.
- **3**: Этот вариант неверен, так как только один студент (Иван) имеет хобби, которое соответствует условию `LIKE '%Хоккей%'`.
- **2**: Этот вариант верен, так как только один студент (Иван) имеет хобби, которое соответствует условию `LIKE '%Хоккей%'`.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 86

Имеется следующая таблица `hobby`:

#### Таблица `hobby`
| id | student | hobby   |
|----|---------|---------|
| 1  | Иван    | Хоккей  |
| 2  | Анна    | Блог    |
| 3  | Ирина   | Чтение  |
| 4  | Иван    | Футбол  |
| 5  | Анна    | Спорт   |

Что вернет следующий SQL-запрос?

```sql
SELECT student 
FROM hobby 
GROUP BY student 
HAVING student NOT IN ('Анна','Ирина') AND COUNT(*) > 1 
LIMIT 1;
```

- [x] Иван
- [ ] Синтаксическая ошибка
- [ ] Ни одной строки
- [ ] Ирина

**Пояснение:**

- **Иван**: Этот вариант верен, так как только у Ивана есть более одного хобби (Хоккей и Футбол) и его имя не входит в список ('Анна', 'Ирина').
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.
- **Ни одной строки**: Этот вариант неверен, так как результат запроса будет содержать строку.
- **Ирина**: Этот вариант неверен, так как у Ирины только одно хобби и её имя входит в список ('Анна', 'Ирина').

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 87
### Какая функция используется для проверки, является ли значение `NULL` в реляционной базе данных?


```sql
SELECT CASE 
    WHEN  ... NULL THEN 'A'
    WHEN NULL IS NOT NULL THEN 'B'
    ELSE 'C'
END AS result;
```

Теперь варианты ответов на вопрос о функциях:

- **ISNULL()**  
  *Функция используется в некоторых СУБД (например, SQL Server) для проверки на `NULL` и замены на другое значение, но не для простой проверки на `NULL`.*

- **NULL_ELSE()**  
  *Такой функции не существует в стандартных СУБД.*

- **NVL()**  
  *Функция используется в Oracle для замены `NULL` значения на другое значение, аналогично `ISNULL()` в SQL Server.*

- **ISNULL**  
  *В MySQL существует оператор `IS NULL` для проверки на `NULL`, но `ISNULL` как функция используется для других целей.*

### Правильный ответ:

Ни один из предложенных вариантов напрямую не отвечает на вопрос о простой проверке значения на `NULL`, так как большинство из них используется для замены `NULL` значениями. Однако для проверки на `NULL` в SQL часто используют синтаксис `IS NULL` или `IS NOT NULL` в условиях и `CASE` выражениях, как показано в примере запроса.

**Замечание:** Если задача состоит в том, чтобы выбрать функцию для работы с `NULL`, то `ISNULL()` и `NVL()` могут быть использованы для замены `NULL` значениями, но они не просто проверяют `NULL`.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 88
### Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(t1.value) 
FROM (SELECT NULL::integer AS value) AS t1;
```

- **Синтаксическая ошибка**  
  *Этот вариант неверен, так как нет синтаксической ошибки в запросе.*

- **1**  
  *Этот вариант неверен, так как `COUNT` считает количество не-NULL значений.*

- **0**  
  *Этот вариант верен, так как `COUNT` считает только не-NULL значения, а в подзапросе значение столбца `value` является `NULL`.*

- **NULL**  
  *Этот вариант неверен, так как функция `COUNT` никогда не возвращает `NULL`; она возвращает число, показывающее количество строк, соответствующих условиям запроса.*

### Правильный ответ:

**0**  
*Функция `COUNT(t1.value)` подсчитывает количество не-NULL значений в столбце `value`. Поскольку в подзапросе `value` установлено как `NULL`, результатом будет 0, так как нет ни одного не-NULL значения для подсчета.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 89
### Что вернет следующий SQL-запрос?

```sql
SELECT 1+1 as value WHEN 1 = 1 OR 2 = 1
```

- **Строки**  
  *Этот вариант неверен, так как он не имеет отношения к типу данных, который возвращает запрос.*

- **NULL**  
  *Этот вариант неверен, так как если запрос был бы корректно составлен, он возвращал бы значение 2.*

- **Синтаксическая ошибка**  
  *Этот вариант верен, так как предложенный запрос содержит синтаксические ошибки. В SQL нет конструкции `WHEN` без `CASE`. Правильная формулировка запроса должна использовать `WHERE`, либо включать `WHEN` в конструкцию `CASE`.*

- **2**  
  *Этот вариант был бы верен, если бы запрос был составлен корректно, например: `SELECT 1+1 AS value WHERE 1 = 1 OR 2 = 1;`.*

### Правильный ответ:

**Синтаксическая ошибка**  
*Запрос содержит синтаксические ошибки и не может быть выполнен в его текущем виде. Для корректного выполнения запроса необходимо использовать правильный синтаксис SQL, например, добавив `CASE` или изменить на `WHERE`.*

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 90
### Что вернет следующий SQL-запрос?

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |

```sql
SELECT count(*) FROM student AS s 
WHERE id NOT IN (SELECT student_id FROM hobby)
```

- **NULL**  
  *Этот вариант неверен, так как функция `COUNT` всегда возвращает число, а не `NULL`.*

- **1**  
  *Этот вариант верен, так как в таблице `student` только Анна (id=2) не имеет соответствующих записей в таблице `hobby`.*

- **Синтаксическая ошибка**  
  *Этот вариант был бы верен для вашего изначального запроса из-за неправильного использования `when`, но после исправления на `where` запрос становится корректным.*

- **3**  
  *Этот вариант неверен, так как не все студенты отсутствуют в таблице `hobby`.*

### Правильный ответ:

**1**  
*Так как только Анна (id=2) из таблицы `student` не имеет записей в таблице `hobby`, запрос `SELECT count(*)` вернет `1`.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 91
### Что вернет следующий SQL-запрос?

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

```sql
SELECT reg_num
FROM student
ORDER BY reg_num NULLS FIRST
LIMIT 1;
```

- **Синтаксическая ошибка**  
  *Этот вариант неверен, так как после исправления запроса на `ORDER BY reg_num NULLS FIRST` он становится синтаксически корректным.*

- **123**  
  *Этот вариант неверен, так как 123 не является первым значением после сортировки, если NULLS размещаются первыми.*

- **456**  
  *Этот вариант неверен, так как 456 также не является первым значением после сортировки.*

- **NULL**  
  *Этот вариант верен, так как с помощью условия `NULLS FIRST` NULL значения будут располагаться в начале списка, и `LIMIT 1` вернет первое из них, то есть NULL.*

### Правильный ответ:

**NULL**  
*Так как `NULLS FIRST` установлено в параметрах сортировки, первым значением, возвращаемым запросом, будет `NULL`. Это соответствует записи для Анны, у которой `reg_num` не установлен.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 92
### Что вернет следующий SQL-запрос?

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

```sql
SELECT s.name, h.hobby 
FROM student AS s 
INNER JOIN hobby AS h ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение'
ORDER BY 1
LIMIT 1;
```

- **NULL, NULL**  
  *Этот вариант неверен, так как запрос возвращает результаты существующих связей между таблицами, и не присутствуют значения NULL в результатах.*

- **Иван, Хоккей**  
  *Этот вариант верен, так как 'Хоккей' соответствует условию выбора, и Иван является первым в алфавитном порядке.*

- **Ирина, Чтение**  
  *Этот вариант неверен, так как хотя 'Чтение' соответствует условию, Ирина не будет первой из-за порядка сортировки.*

- **Ни одной строки**  
  *Этот вариант неверен, так как запрос определенно вернет строки, поскольку условия `WHERE` совпадают с данными в таблицах.*

### Правильный ответ:

**Иван, Хоккей**  
*Запрос возвращает имя Ивана и хобби Хоккей, так как это первая строка, удовлетворяющая условиям `WHERE` и сортировки. Иван стоит первым в алфавитном порядке по именам, когда сортировка выполняется по первому столбцу.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 93
### Что вернет следующий SQL-запрос?

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

```sql
SELECT s.name, h.hobby 
FROM student AS s 
LEFT JOIN hobby AS h ON s.id = h.student_id
ORDER BY h.hobby NULLS FIRST
LIMIT 1;
```

- **Строки**  
  *Этот вариант неверен, так как ответ должен конкретизировать, какие строки будут возвращены.*

- **NULL, Плавание**  
  *Этот вариант неверен, так как Плавание связано со студентом id=4, которого нет в таблице `student`.*

- **Анна, NULL**  
  *Этот вариант верен, так как Анна (id=2) не имеет связанных записей в таблице `hobby`, и при использовании `LEFT JOIN` для неё будет возвращено значение `NULL` в столбце `hobby`. При сортировке `NULLS FIRST`, Анна с NULL в `hobby` будет первой.*

- **Иван, Музыка**  
  *Этот вариант неверен, так как хотя Иван и связан с хобби "Музыка", при сортировке `NULLS FIRST` он не окажется первым, так как у него нет `NULL` в `hobby`.*

### Правильный ответ:

**Анна, NULL**  
*Поскольку Анна не имеет связанных записей в таблице `hobby`, и при использовании `LEFT JOIN` для неё будет возвращено значение `NULL` в столбце `hobby`. Это сочетание условий делает её первой строкой в результате запроса при сортировке `NULLS FIRST`.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 94
### Что вернет следующий SQL-запрос?

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

```sql
SELECT employee, SUM(transaction)
FROM employee
GROUP BY employee
ORDER BY 1
LIMIT 1;
```

- **Иван 430**  
  *Этот вариант неверен, так как сумма транзакций Ивана составляет 430, но при алфавитном упорядочении по имени `employee`, Иван не будет первым.*

- **Анна 245**  
  *Этот вариант верен, так как Анна алфавитно первая, и сумма её транзакций составляет 245.*

- **Ирина 50**  
  *Этот вариант неверен, так как хотя сумма транзакций Ирины составляет 50, Ирина не первая в алфавитном порядке.*

- **Синтаксическая ошибка**  
  *Этот вариант неверен, так как в запросе нет синтаксических ошибок.*

### Правильный ответ:

**Анна 245**  
*Запрос правильно суммирует транзакции для каждого сотрудника и группирует их по имени. Анна алфавитно первая, поэтому результатом запроса будет строка для Анны с суммой транзакций 245, так как запрос сортирует результаты по имени сотрудника и возвращает первую строку.*

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 95
### Что вернет следующий исправленный SQL-запрос?

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

```sql
SELECT DISTINCT employee as emp 
FROM employee
WHERE transaction > 50 AND transaction <= 300
ORDER BY 1
LIMIT 1;
```

- **Иван**  
  *Иван выполняет условие запроса с транзакциями 100, но из-за сортировки и уникальности выборки не может быть первым, если Анна также соответствует условиям.*

- **Анна**  
  *Анна соответствует условиям (транзакция 200), и поскольку она алфавитно первая, она будет первым и единственным результатом запроса с `LIMIT 1`.*

- **Ирина**  
  *Ирина не удовлетворяет условиям выборки, так как её транзакция либо равна 50, что ниже порога, либо нет других записей больше 50 и до 300.*

- **Синтаксическая ошибка**  
  *Этот вариант был бы верен для вашего изначального запроса из-за использования `DESTINC` вместо `DISTINCT`.*

### Правильный ответ:

**Анна**  
*Анна соответствует условиям запроса с транзакцией 200, что находится в заданном диапазоне. Поскольку она алфавитно первая среди кандидатов, её имя будет первым и единственным результатом возвращенным запросом, что соответствует ограничению `LIMIT 1`.*

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 96
### Что вернет следующий исправленный SQL-запрос?

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

### SQL-запрос:
```sql
SELECT COUNT(DISTINCT employee)
FROM employee
WHERE transaction BETWEEN 50 AND 300;
```

### Разбор данных:
- **Иван**: У Ивана есть транзакции 100 и 330. Транзакция 330 не попадает в заданный диапазон, но транзакция 100 подходит.
- **Анна**: У Анны транзакции 200 и 45. Транзакция 45 не входит в диапазон, но 200 подходит.
- **Ирина**: У Ирины транзакция ровно 50, что является границей диапазона, поэтому она включается в подсчет.

Таким образом, у нас есть три уникальных сотрудника (Иван, Анна, Ирина), которые удовлетворяют условиям запроса.

### Ответ:
**3**

Это число уникальных сотрудников, у которых есть транзакции в диапазоне от 50 до 300.

[↑ Вернуться к оглавлению](#оглавление)

