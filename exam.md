
## Оглавление
<details><summary>Вопросы без таблиц и запросов</summary>

1. [Вопросы без таблиц и запросов](#вопросы-без-таблиц-и-запросов) 
    1. [Вопрос 1](#вопрос-1)
    2. [Вопрос 2](#вопрос-2)
    3. [Вопрос 3](#вопрос-3)
    4. [Вопрос 4](#вопрос-4)
    5. [Вопрос 5](#вопрос-5)
    6. [Вопрос 6](#вопрос-6)
    7. [Вопрос 7](#вопрос-7)
    8. [Вопрос 8](#вопрос-8)
    9. [Вопрос 9](#вопрос-9)
    10. [Вопрос 10](#вопрос-10)
    11. [Вопрос 11](#вопрос-11)
    12. [Вопрос 12](#вопрос-12)
    13. [Вопрос 13](#вопрос-13)
    14. [Вопрос 14](#вопрос-14)
    15. [Вопрос 15](#вопрос-15)
    16. [Вопрос 16](#вопрос-16)
    17. [Вопрос 17](#вопрос-17)
    18. [Вопрос 18](#вопрос-18)
    19. [Вопрос 19](#вопрос-19)
    20. [Вопрос 20](#вопрос-20)
    21. [Вопрос 21](#вопрос-21)
    22. [Вопрос 22](#вопрос-22)
    23. [Вопрос 23](#вопрос-23)
    24. [Вопрос 24](#вопрос-24)
    25. [Вопрос 25](#вопрос-25)
    26. [Вопрос 26](#вопрос-26)
    27. [Вопрос 27](#вопрос-27)
</details>
<details><summary>Вопросы с таблицами и запросами</summary>

2. [Вопросы с таблицами и запросами](#вопросы-с-таблицами-и-запросами)
    1. [Вопрос 28](#вопрос-28)
    2. [Вопрос 29](#вопрос-29)
    3. [Вопрос 30](#вопрос-30)
    4. [Вопрос 31](#вопрос-31)
    5. [Вопрос 32](#вопрос-32)
    6. [Вопрос 33](#вопрос-33)
    7. [Вопрос 34](#вопрос-34)
    8. [Вопрос 35](#вопрос-35)
    9. [Вопрос 36](#вопрос-36)
    10. [Вопрос 37](#вопрос-37)
    11. [Вопрос 38](#вопрос-38)
    12. [Вопрос 39](#вопрос-39)
    13. [Вопрос 40](#вопрос-40)
    14. [Вопрос 41](#вопрос-41)
    15. [Вопрос 42](#вопрос-42)
    16. [Вопрос 43](#вопрос-43)
    17. [Вопрос 44](#вопрос-44)
    18. [Вопрос 45](#вопрос-45)
    19. [Вопрос 46](#вопрос-46)

</details>

## Вопросы без таблиц и запросов 

#### Вопрос 1
Что концептуально представляют собой атрибуты сущности в ER-модели?

- [x] Характеристики или свойства сущности, которые описывают данные, относящиеся к этой сущности.
- [ ] Объекты или вещи в системе.
- [ ] Отношения между сущностями.
- [ ] Уникальные идентификаторы сущностей.

[↑ Вернуться к оглавлению](#оглавление)


#### Вопрос 2
Какой из языков обычно используется для описания логических моделей данных?

- [ ] HTML
- [ ] UML
- [ ] JSON
- [x] SQL

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 3
Какое из следующих понятий описывает связь между двумя сущностями в логической модели данных?

- [ ] Хеш-код
- [ ] Тригер
- [ ] Индекс
- [x] Внешний ключ (Foreign Key)

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 4
Что представляет собой первая нормальная форма (1NF) в реляционном дизайне баз данных?

- [x] Все значения атрибутов атомарные (неделимые), каждый столбец содержит только одно значение.
- [ ] Наличие уникального идентификатора для каждой записи.
- [ ] Сущность имеет как минимум один атрибут.
- [ ] Поддержание ссылочной целостности.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 5
Что такое первичный ключ в физической модели данных?

- [x] Уникальный идентификатор строки в таблице, который однозначно определяет каждую запись.
- [ ] Свойство сущности, описывающее данные.
- [ ] Атрибут, который может принимать только уникальные значения.
- [ ] Показатель, определяющий количество связей между сущностями.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 6
Какое действие будет предпринято, если объект CHECK CONSTRAINT не пройдет при вставке или обновлении данных?

- [ ] Данные будут вставлены/обновлены, но с предупреждением.
- [ ] Данные будут вставлены/обновлены без изменений.
- [x] Вызвано исключение, и операция не будет выполнена.
- [ ] Будет выполнена попытка исправить данные автоматически.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 7
Какая команда используется для создания FOREIGN KEY?

- [x] ALTER TABLE ... ADD CONSTRAINT ... FOREIGN KEY
- [ ] CREATE TABLE ... FOREIGN KEY
- [ ] ADD FOREIGN KEY TO TABLE ...
- [ ] MODIFY TABLE ... ADD FOREIGN KEY

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 8
Какая DDL команда используется для создания CHECK CONSTRAINT?

- [x] ALTER TABLE ... ADD CONSTRAINT ... CHECK
- [ ] CREATE TABLE ... CHECK CONSTRAINT
- [ ] ADD CHECK CONSTRAINT TO TABLE ...
- [ ] MODIFY TABLE ... ADD CHECK

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 9
Что подходит под термин <Реляционная база данных>?

- [x] База данных, которая использует реляционную модель для хранения и управления данными.
- [ ] База данных, которая использует объектно-ориентированную модель для хранения данных.
- [ ] Файловая система, использующая реляционные таблицы.
- [ ] База данных, работающая на основе графовых данных.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 10
Что НЕ подходит под термин <Реляционная база данных>?

- [x] Нереляционные базы данных, такие как документно-ориентированные базы.
- [x] Ключ-значение хранилища.
- [x] Колонно-ориентированные базы данных.
- [x] Графовые базы данных.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 11
Кто управляет доступами к данным в реляционной базе данных?

- [x] DBMS (Database Management System)
- [ ] quercy optimaze
- [ ] transacthion
- [ ] sql serve

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 12
Что означает аббревиатура <CAP> в концепции CAP-теоремы?

- [x] Consistency (Согласованность), Availability (Доступность), Partition Tolerance (Устойчивость к разделению сети)
- [ ] Consistency (Согласованность), Accuracy (Точность), Performance (Производительность)
- [ ] Control (Контроль), Availability (Доступность), Partition (Разделение)
- [ ] Consistency (Согласованность), Availability (Доступность), Performance (Производительность)

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 13
Какой принцип гарантии ACID гарантирует, что если транзакция прошла успешно, изменения будут сохранены даже в случае сбоя системы?

- [x] Долговечность (Durability)
- [ ] Атомарность (Atomicity)
- [ ] Согласованность (Consistency)
- [ ] Изолированность (Isolation)

[↑ Вернуться к оглавлению](#оглавление)


### Вопрос 14

При попытке удаления записи из родительской таблицы сущности с установленным внешним ключом (FOREIGN KEY) и параметром `ON DELETE CASCADE`, что произойдет?

- [ ] Запись в родительской таблице будет удалена, а записи в дочерней таблице останутся без изменений.
- [ ] Будет вызвано исключение, и запись не будет удалена.
- [ ] Запись в родительской таблице будет удалена, а связанные записи в дочерней таблице будут обновлены.
- [x] Запись в родительской таблице будет удалена, и все связанные записи в дочерней таблице также будут автоматически удалены.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 15

Какие типы индексов используются в реляционных базах данных?

- [ ] Гибкие (Flexible)
- [ ] Кластерные (Clustered)
- [x] Полнотекстовые (Full-Text)
- [x] Уникальные (Unique)

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 16

Какова цель логического моделирования данных?

- [ ] Обеспечить физическое хранение данных на диске.
- [ ] Оптимизировать запросы к базе данных.
- [ ] Определить структуру базы данных, не зависящую от СУБД.
- [x] Описать данные и их отношения на концептуальном уровне, независимо от физического хранения.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Описать данные и их отношения на концептуальном уровне, независимо от физического хранения**:
  - Логическое моделирование данных направлено на создание абстрактной модели, которая описывает данные и их отношения без привязки к конкретной СУБД или физическим аспектам хранения данных. Эта модель помогает понять структуру данных и их взаимосвязи на высоком уровне.

### Неправильные ответы

- **Обеспечить физическое хранение данных на диске**:
  - Это задача физического моделирования данных, а не логического.

- **Оптимизировать запросы к базе данных**:
  - Оптимизация запросов относится к аспектам реализации и выполнения запросов, что также выходит за рамки логического моделирования данных.

- **Определить структуру базы данных, не зависящую от СУБД**:
  - Логическое моделирование действительно определяет структуру данных, но этот ответ не полностью отражает цель описания данных и их отношений на концептуальном уровне.


### Вопрос 17 

Какой метод используется для нормализации логических моделей данных?

- [ ] Индексация
- [ ] Кэширование
- [x] Нормализация
- [ ] Репликация

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Нормализация**:
  - Нормализация – это метод, используемый для организации атрибутов и таблиц реляционной базы данных для минимизации избыточности данных и предотвращения аномалий при обновлении. Она включает в себя применение различных нормальных форм (1NF, 2NF, 3NF и т.д.), чтобы обеспечить логическую согласованность и целостность данных.

### Неправильные ответы

- **Индексация**:
  - Индексация используется для ускорения выполнения запросов, но не для нормализации данных.

- **Кэширование**:
  - Кэширование используется для хранения часто запрашиваемых данных в памяти для быстрого доступа, но не связано с нормализацией данных.

- **Репликация**:
  - Репликация используется для создания копий данных для обеспечения их доступности и отказоустойчивости, но не для нормализации данных.

### Вопрос 18

Что такое CHECK CONSTRAINT в реляционной базе данных?

- [ ] Ограничение, которое гарантирует, что все значения в столбце являются уникальными.
- [x] Ограничение, которое гарантирует, что все значения в столбце или наборе столбцов удовлетворяют определенному логическому условию.
- [ ] Ограничение, которое устанавливает связь между двумя таблицами.
- [ ] Ограничение, которое предотвращает удаление строк из таблицы.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CHECK CONSTRAINT**:
  - CHECK CONSTRAINT (ограничение проверки) используется для обеспечения того, что все значения в столбце или наборе столбцов соответствуют заданному логическому условию. Это условие может включать проверку диапазона значений, соответствие шаблону или любую другую логическую проверку, определенную пользователем.

### Неправильные ответы

- **Ограничение, которое гарантирует, что все значения в столбце являются уникальными**:
  - Это описание UNIQUE CONSTRAINT, а не CHECK CONSTRAINT.

- **Ограничение, которое устанавливает связь между двумя таблицами**:
  - Это описание FOREIGN KEY CONSTRAINT.

- **Ограничение, которое предотвращает удаление строк из таблицы**:
  - Это не связано с CHECK CONSTRAINT. Это может быть связано с другими мерами безопасности или ограничениями в базе данных.

### Вопрос 19

Какой из перечисленных факторов НЕ влияет на процесс проектирования физической модели базы данных?

- [x] Инструмент проектирования физической модели
- [ ] Сложность бизнес-логики
- [ ] Объем данных
- [ ] Требования к производительности

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Инструмент проектирования физической модели**:
  - Инструмент проектирования может влиять на удобство и скорость работы, но не на сам процесс проектирования физической модели базы данных. Факторы, связанные с архитектурой, объемом данных и производительностью, оказывают непосредственное влияние на проектирование.

### Неправильные ответы

- **Сложность бизнес-логики**:
  - Сложность бизнес-логики влияет на проектирование физической модели, так как более сложная логика может требовать более сложных структур данных и индексов.

- **Объем данных**:
  - Объем данных напрямую влияет на процесс проектирования физической модели, так как большой объем данных может требовать особого подхода к хранению и индексации для обеспечения производительности и масштабируемости.

- **Требования к производительности**:
  - Требования к производительности сильно влияют на процесс проектирования физической модели, так как они определяют, как данные должны быть распределены и индексированы для обеспечения оптимальной производительности.

### Вопрос 20

Какая команда DDL используется для добавления ограничения CHECK CONSTRAINT в уже существующую таблицу?

- [ ] CREATE TABLE ... ADD CONSTRAINT ... CHECK
- [ ] ALTER TABLE ... MODIFY CONSTRAINT ... CHECK
- [x] ALTER TABLE ... ADD CONSTRAINT ... CHECK
- [ ] UPDATE TABLE ... ADD CONSTRAINT ... CHECK

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **ALTER TABLE ... ADD CONSTRAINT ... CHECK**:
  - Эта команда используется для добавления ограничения CHECK в уже существующую таблицу. Она позволяет определить условие, которому должны соответствовать данные в столбце или наборе столбцов.

### Пример использования

```sql
ALTER TABLE table_name
ADD CONSTRAINT constraint_name CHECK (condition);
```
### Вопрос 21

Какая команда DDL используется для создания уникального индекса в реляционной базе данных?

- [ ] CREATE TABLE ... UNIQUE INDEX
- [ ] ALTER TABLE ... ADD UNIQUE INDEX
- [x] CREATE UNIQUE INDEX ... ON ...
- [ ] UPDATE TABLE ... ADD UNIQUE INDEX

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CREATE UNIQUE INDEX ... ON ...**:
  - Эта команда используется для создания уникального индекса на столбце или наборе столбцов в уже существующей таблице. Уникальный индекс гарантирует, что все значения в индексируемых столбцах будут уникальными.

### Пример использования

```sql
CREATE UNIQUE INDEX index_name 
ON table_name (column_name);
```
### Вопрос 22

Что означает уровень изоляции транзакций `READ UNCOMMITTED` в реляционной базе данных?

- [ ] Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями.
- [ ] Транзакция может видеть изменения, которые были зафиксированы другими транзакциями, но не свои собственные.
- [x] Транзакция может видеть все изменения, включая те, которые еще не были зафиксированы другими транзакциями.
- [ ] Транзакция не может видеть никакие изменения, пока они не будут зафиксированы.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Транзакция может видеть все изменения, включая те, которые еще не были зафиксированы другими транзакциями**:
  - Уровень изоляции `READ UNCOMMITTED` позволяет транзакции читать данные, которые были изменены другими транзакциями, но еще не были зафиксированы. Это может привести к ситуации, известной как "грязное чтение" (dirty read), где транзакция читает данные, которые могут быть впоследствии откатаны.

### Неправильные ответы

- **Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями**:
  - Это описание уровня изоляции `READ COMMITTED`.

- **Транзакция может видеть изменения, которые были зафиксированы другими транзакциями, но не свои собственные**:
  - Нет такого стандартного уровня изоляции в SQL.

- **Транзакция не может видеть никакие изменения, пока они не будут зафиксированы**:
  - Это описание более строгого уровня изоляции, например, `SERIALIZABLE`.


### Вопрос 23

Какие из перечисленных операций являются пользовательскими операциями в реляционной базе данных?

- [ ] JSON
- [ ] RAD
- [ ] HTTP
- [x] CRUD

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CRUD**:
  - CRUD — это аббревиатура, обозначающая четыре основные операции, которые выполняются пользователями в реляционной базе данных: Create (создание), Read (чтение), Update (обновление), Delete (удаление). Эти операции являются основными для работы с данными в базе данных и позволяют пользователям взаимодействовать с хранимыми данными.

### Неправильные ответы

- **JSON**:
  - JSON (JavaScript Object Notation) — это формат данных для передачи и хранения структурированных данных, но не является пользовательской операцией в реляционной базе данных.

- **RAD**:
  - RAD (Rapid Application Development) — это методология быстрой разработки приложений, а не пользовательская операция в реляционной базе данных.

- **HTTP**:
  - HTTP (Hypertext Transfer Protocol) — это протокол передачи гипертекста, используемый в сети Интернет, но не является пользовательской операцией в реляционной базе данных.

### Вопрос 24

Какие типы баз данных наиболее подходят для работы с социальными сетями и рекомендательными системами?

- [ ] Реляционные базы данных (Relational)
- [ ] Документно-ориентированные базы данных (Document)
- [x] NoSQL базы данных (NoSQL)
- [x] Графовые базы данных (Graph)

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **NoSQL базы данных (NoSQL)**:
   - NoSQL базы данных часто используются для работы с большими объемами неструктурированных данных и обеспечивают высокую производительность и масштабируемость. Они могут быть полезны для хранения и обработки данных социальных сетей и рекомендательных систем.

2. **Графовые базы данных (Graph)**:
   - Графовые базы данных особенно подходят для работы с данными социальных сетей, где важны связи и взаимодействия между пользователями. Они позволяют эффективно хранить и запрашивать данные о связях и рекомендациях.

### Неправильные ответы

- **Реляционные базы данных (Relational)**:
  - Хотя реляционные базы данных могут использоваться для некоторых задач в социальных сетях и рекомендательных системах, они могут не справляться с задачами, требующими масштабируемости и гибкости, особенно при работе с большими объемами данных и сложными связями.

- **Документно-ориентированные базы данных (Document)**:
  - Документно-ориентированные базы данных подходят для хранения данных в формате документов, но они не всегда оптимальны для задач, связанных с анализом сложных взаимосвязей, которые характерны для социальных сетей и рекомендательных систем.

### Вопрос 25

Что представляет собой отношение (таблица) в реляционной базе данных?

- [ ] Набор документов, хранящихся в формате JSON.
- [ ] Граф данных, отображающий связи между узлами.
- [x] Множество строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут.
- [ ] Структура данных, организованная в виде ключ-значение.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Множество строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут**:
  - В реляционной базе данных отношение (таблица) представляет собой двумерную структуру данных, состоящую из строк (записей) и столбцов (атрибутов). Каждая строка в таблице соответствует одной записи, а каждый столбец соответствует одному атрибуту записи. Таблицы используются для хранения и организации данных в реляционных базах данных.

### Неправильные ответы

- **Набор документов, хранящихся в формате JSON**:
  - Это описание документно-ориентированных баз данных, а не реляционных.

- **Граф данных, отображающий связи между узлами**:
  - Это описание графовых баз данных, а не реляционных.

- **Структура данных, организованная в виде ключ-значение**:
  - Это описание базы данных типа ключ-значение, а не реляционных баз данных.

### Вопрос 26

Какие базы данных удовлетворяют свойствам "CA" (Consistency and Availability) из CAP-теоремы?

- [x] PostgreSQL
- [x] MySQL
- [ ] Cassandra
- [ ] HBase

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **PostgreSQL**:
   - PostgreSQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

2. **MySQL**:
   - MySQL — это еще одна реляционная база данных, которая также обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

### Неправильные ответы

- **Cassandra**:
  - Cassandra — это распределенная база данных, которая акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но не всегда на согласованности (Consistency).

- **HBase**:
  - HBase — это распределенная, масштабируемая база данных, которая также акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но не всегда на согласованности (Consistency).

### Вопрос 27

Какие базы данных удовлетворяют свойствам "AP" (Availability and Partition Tolerance) из CAP-теоремы?

- [ ] PostgreSQL
- [ ] MySQL
- [x] Cassandra
- [x] HBase

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **Cassandra**:
   - Cassandra — это распределенная база данных, которая обеспечивает высокую доступность (Availability) и устойчивость к разделению сети (Partition Tolerance), но может не гарантировать строгую согласованность (Consistency) во всех случаях.

2. **HBase**:
   - HBase — это распределенная, масштабируемая база данных, которая также акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но может не гарантировать строгую согласованность (Consistency).

### Неправильные ответы

- **PostgreSQL**:
  - PostgreSQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

- **MySQL**:
  - MySQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).


### Вопрос 28

Что вернет следующий SQL-запрос?

```sql
SELECT CASE 
           WHEN NULL = 5 THEN 'a' 
           WHEN NULL <> 5 THEN 'b' 
           ELSE 'c' 
       END AS result;
```

- [ ] 'a'
- [ ] 'b'
- [x] 'c'
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **'c'**:
  - В SQL любое сравнение с `NULL` всегда возвращает `NULL`. Таким образом, условия `WHEN NULL = 5` и `WHEN NULL <> 5` не выполнятся, и будет возвращено значение из блока `ELSE`, то есть 'c'.

---

### Вопрос 29

Что делает следующий SQL-запрос?

```sql
SELECT SUM(t1.value) 
FROM (SELECT NULL::integer AS value) AS t1;
```

- [ ] Возвращает 0
- [x] Возвращает NULL
- [ ] Возвращает ошибку
- [ ] Возвращает 1

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Возвращает NULL**:
  - Функция `SUM` игнорирует значения `NULL`, но если все значения, которые нужно суммировать, являются `NULL`, результат будет `NULL`.

---

### Вопрос 30

Что вернет следующий SQL-запрос?

```sql
SELECT 1 + 1 AS value 
WHERE 1 = 1 AND 1 = 2;
```

- [ ] 2
- [ ] 1
- [ ] 0
- [x] Ничего (пустой результат)

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ничего (пустой результат)**:
  - Условие `WHERE 1 = 1 AND 1 = 2` всегда ложно, поэтому запрос не вернет ни одной строки.

---
### Вопрос 31

Что вернет следующий SQL-запрос в PostgreSQL?

```sql
SELECT 'Привет' || NULL || 'друзья!' AS result;
```

- [ ] Привет NULL друзья!
- [ ] NULL
- [ ] Привет друзья!
- [x] NULL друзья!

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **NULL**:
  - В PostgreSQL оператор конкатенации `||` возвращает `NULL`, если любой из его операндов равен `NULL`. Таким образом, результатом данного запроса будет `NULL`.

---

### Вопрос 32

Что делает следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE EXISTS (
    SELECT NULL 
    FROM hobby AS h 
    WHERE h.student_id = s.student_id
);
```

- [x] Считает количество студентов, у которых есть хотя бы одно хобби
- [ ] Считает количество студентов, у которых нет хобби
- [ ] Возвращает количество всех записей в таблице `hobby`
- [ ] Возвращает количество всех записей в таблице `student`

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Считает количество студентов, у которых есть хотя бы одно хобби**:
  - Подзапрос проверяет существование записи в таблице `hobby`, связанной со студентом из таблицы `student`. `COUNT(*)` возвращает количество таких студентов.

---

### Вопрос 33

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT DISTINCT employee AS emp 
FROM employee 
WHERE transaction BETWEEN 50 AND 300 
ORDER BY 1 
LIMIT 1;
```

- [x] Иван
- [ ] Анна
- [ ] Ирина
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван**:
  - Запрос выбирает уникальные значения столбца `employee` (псевдоним `emp`), где значение в столбце `transaction` находится в диапазоне от 50 до 300 включительно, сортирует результаты по имени сотрудника и ограничивает результат одной строкой. Поскольку значения `transaction` для Ивана (100) и Анны (200) находятся в этом диапазоне, но Иван идет первым по алфавиту после сортировки, будет возвращено значение Иван.

### Уточнение по синтаксису запроса

В оригинальном запросе есть несколько синтаксических ошибок:
- `distion` должно быть `DISTINCT`
- `beetween` должно быть `BETWEEN`
- Пробелы и форматирование следует уточнить для лучшей читаемости

Исправленный запрос:

```sql
SELECT DISTINCT employee AS emp 
FROM employee 
WHERE transaction BETWEEN 50 AND 300 
ORDER BY 1 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблицы, результат будет:

| emp  |
|------|
| Иван |

---
### Вопрос 34

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT string_agg(t1.id::VARCHAR, ',' ORDER BY t1.id) AS result 
FROM (
    SELECT s.id FROM student AS s 
    UNION ALL 
    SELECT h.student_id FROM hobby AS h
) AS t1;
```

- [ ] 1,2,3
- [ ] 1,1,3,4
- [x] 1,1,2,3,3,4
- [ ] 1,1,2,3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1,1,2,3,3,4**:
  - Подзапрос выбирает `id` из таблицы `student` и `student_id` из таблицы `hobby`, объединяя их с помощью `UNION ALL`. Результат будет содержать все `id` и `student_id`, включая дубликаты. Функция `string_agg` объединяет эти значения в строку, разделяя их запятой, и сортирует их по `id`.

### Уточнение по синтаксису запроса

Исправленный запрос:

```sql
SELECT string_agg(t1.id::VARCHAR, ',' ORDER BY t1.id) AS result 
FROM (
    SELECT s.id FROM student AS s 
    UNION ALL 
    SELECT h.student_id FROM hobby AS h
) AS t1;
```

### Пример выполнения запроса

| result       |
|--------------|
| 1,1,2,3,3,4  |

---
### Вопрос 35

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что произойдет при выполнении следующего SQL-запроса?

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    RIGHT JOIN hobby AS h 
    ON s.id = h.student_id 
    ORDER BY s.name NULLS FIRST 
    LIMIT 1
),
_b AS (
    SELECT 1 / 0 AS res
)
SELECT * 
FROM _a 
INNER JOIN _b;
```

- [x] Синтаксическая ошибка
- [ ] Иван, Музыка
- [ ] NULL, Плавание
- [ ] Анна, NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Синтаксическая ошибка**:
  - В запросе есть несколько синтаксических ошибок. Во-первых, ключевое слово `WITH` должно быть использовано правильно для объявления временных таблиц. Во-вторых, попытка деления на ноль (`1 / 0`) вызовет ошибку выполнения, но основная проблема здесь — синтаксическая ошибка в объявлении CTE.

### Уточнение по синтаксису запроса

Запрос должен быть исправлен для правильного выполнения:

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    RIGHT JOIN hobby AS h 
    ON s.id = h.student_id 
    ORDER BY s.name NULLS FIRST 
    LIMIT 1
),
_b AS (
    SELECT 1 / 0 AS res
)
SELECT * 
FROM _a 
INNER JOIN _b;
```

### Пример выполнения запроса

При выполнении данного запроса база данных вернет ошибку, так как есть синтаксическая ошибка и деление на ноль не является допустимой операцией.

---
### Вопрос 36

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT NULL 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [ ] 1
- [x] 1
- [ ] 2
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос выбирает количество студентов, у которых нет соответствующих записей в таблице `hobby`. В данном случае, студент с `id = 2` (Анна) не имеет записей в таблице `hobby`, поэтому результатом будет `1`.

---

### Вопрос 37

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE id NOT IN (
    SELECT student_id 
    FROM hobby 
    WHERE hobby ILIKE '%Хоккей%'
);
```

- [ ] 1
- [ ] 2
- [x] 2
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **2**:
  - Запрос выбирает количество студентов, у которых нет хобби, содержащего слово "Хоккей". В данном случае, только у студента с `id = 1` (Иван) есть хобби "Хоккей". Поэтому студенты с `id = 2` (Анна) и `id = 3` (Ирина) будут включены в результат, что дает итоговый счет 2.
  `ILIKE` используется в PostgreSQL для нечувствительного к регистру поиска по шаблону. 
---

### Вопрос 38

Имеется следующая таблица `student`:

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

Что вернет следующий SQL-запрос?

```sql
SELECT reg_num 
FROM student 
ORDER BY reg_num NULLS LAST 
LIMIT 1;
```

- [ ] 123
- [ ] 456
- [ ] NULL
- [x] 123

### Пояснение к правильному ответу

- **123**:
  - Запрос выбирает значения столбца `reg_num` из таблицы `student`, сортируя их по возрастанию с размещением значений `NULL` в конце (`NULLS LAST`), и ограничивает результат одной строкой (`LIMIT 1`). Поскольку 123 является наименьшим ненулевым значением, оно будет первым в отсортированном списке, и результатом будет 123.

---
### Вопрос 39

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
CROSS JOIN hobby AS h 
ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван, Музыка
- [ ] Анна, Хоккей
- [ ] Ирина, Плавание
- [x] Иван, Хоккей

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван, Хоккей**:
  - Запрос выполняет `CROSS JOIN` (в данном случае это синтаксическая ошибка, так как для `CROSS JOIN` не требуется условие `ON`) между таблицами `student` и `hobby`, и затем фильтрует результаты, чтобы включить только те строки, где хобби равно 'Хоккей' или 'Чтение'. Поскольку значение 'Хоккей' связано со студентом Иван, и 'Чтение' связано со студенткой Ириной, после сортировки по имени и ограничения одной строкой, результатом будет Иван, Хоккей.

### Уточнение по синтаксису запроса

Запрос должен использовать `INNER JOIN` или `JOIN`, так как `CROSS JOIN` не требует условия `ON`.

Исправленный запрос:

```sql
SELECT s.name, h.hobby 
FROM student AS s 
JOIN hobby AS h 
ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Иван | Хоккей |

---

### Вопрос 40

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    LEFT JOIN hobby AS h 
    ON s.id = h.student_id
)
SELECT * 
FROM _a 
ORDER BY name NULLS FIRST 
LIMIT 1;
```

- [ ] Анна, NULL
- [ ] Иван, Хоккей
- [x] Анна, NULL
- [ ] Ирина, Чтение

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Анна, NULL**:
  - Запрос использует CTE (`WITH _a AS ...`), который выполняет левое соединение (`LEFT JOIN`) таблиц `student` и `hobby` по условию `s.id = h.student_id`. Затем основной запрос выбирает все строки из CTE `_a`, сортирует их по имени, помещая значения `NULL` в начало (`NULLS FIRST`), и ограничивает результат одной строкой (`LIMIT 1`). Поскольку Анна не имеет записи в таблице `hobby`, результат будет `Анна, NULL`.

### Уточнение по синтаксису запроса

Запрос синтаксически корректен и не требует изменений.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Анна | NULL  |

---

### Вопрос 41

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT (2 + 2 * 2) 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [ ] 1
- [ ] 2
- [x] 1
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос выбирает количество студентов, у которых нет соответствующих записей в таблице `hobby`. В данном случае, студент с `id = 2` (Анна) не имеет записей в таблице `hobby`, поэтому результатом будет `1`.

### Уточнение по синтаксису запроса

В оригинальном запросе есть синтаксическая ошибка: `when` должно быть `where`.

Исправленный запрос:

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT (2 + 2 * 2) 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблиц, результат будет:

| count |
|-------|
| 1     |

### Вопрос 42

Имеется следующая таблица `student`:

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

Что вернет следующий SQL-запрос?

```sql
SELECT reg_num 
FROM student 
ORDER BY CASE 
            WHEN reg_num IS NULL THEN 1 
            ELSE reg_num 
         END 
LIMIT 1;
```

- [ ] 123
- [ ] 456
- [x] 1
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос сортирует таблицу `student` по `reg_num`, используя конструкцию `CASE WHEN reg_num IS NULL THEN 1 ELSE reg_num END`. Это приводит к тому, что значения `NULL` обрабатываются как 1. После сортировки результаты ограничиваются одной строкой (`LIMIT 1`). Поскольку строка с `reg_num` равным `NULL` будет заменена на 1 в сортировке, она будет первой в списке. 

### Уточнение по синтаксису запроса

В оригинальном запросе есть синтаксическая ошибка: `them` должно быть `then`.

Исправленный запрос:

```sql
SELECT reg_num 
FROM student 
ORDER BY CASE 
            WHEN reg_num IS NULL THEN 1 
            ELSE reg_num 
         END 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблицы, результат будет:

| reg_num |
|---------|
| 1       |

---
### Вопрос 43

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT employee, SUM(transaction) 
FROM employee 
GROUP BY employee 
HAVING MIN(transaction) = MAX(transaction) 
ORDER BY employee 
LIMIT 1;
```

- [ ] Иван, 430
- [ ] Анна, 245
- [x] Ирина, 50
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ирина, 50**:
  - Запрос группирует строки по столбцу `employee`, а затем применяет условие `HAVING MIN(transaction) = MAX(transaction)`, чтобы выбрать только тех сотрудников, у которых все значения `transaction` одинаковы. В данном случае это применимо только к Ирине, так как у неё одна транзакция равна 50. Запрос затем суммирует транзакции для каждого сотрудника, сортирует результат по имени и ограничивает результат одной строкой (`LIMIT 1`). Иван и Анна имеют разные значения транзакций, поэтому они не будут включены в результат.

### Уточнение по синтаксису запроса

Запрос синтаксически корректен и не требует изменений.

### Пример выполнения запроса

С учетом данных таблицы, результат будет:

| employee | sum(transaction) |
|----------|------------------|
| Ирина    | 50               |

---
### Вопрос 44

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT employee 
FROM (
    SELECT employee, 
           ROW_NUMBER() OVER (ORDER BY transaction) AS row_num 
    FROM employee 
    GROUP BY employee
) AS t1 
WHERE t1.row_num != 2 
ORDER BY employee DESC 
LIMIT 1;
```

- [ ] Иван
- [ ] Анна
- [x] Ирина
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ирина**:
  - Запрос использует оконную функцию `ROW_NUMBER()` для нумерации строк на основе значения `transaction`, группирует данные по `employee`. Затем внешний запрос выбирает всех сотрудников, у которых `row_num` не равно 2, сортирует результат по имени сотрудника в порядке убывания и ограничивает результат одной строкой (`LIMIT 1`). Поскольку `ROW_NUMBER()` присваивает номера строкам на основе значения `transaction`, и учитывая, что у нас только три уникальных имени, результатом будет Ирина, так как у неё наименьшее значение `transaction`.

### Уточнение по синтаксису запроса

В оригинальном запросе есть синтаксическая ошибка: необходимо учитывать все строки, чтобы `ROW_NUMBER()` работал корректно. Группировка по одному столбцу приводит к некорректной работе `ROW_NUMBER()`.

Исправленный запрос:

```sql
SELECT employee 
FROM (
    SELECT employee, 
           ROW_NUMBER() OVER (ORDER BY transaction) AS row_num 
    FROM employee
) AS t1 
WHERE t1.row_num != 2 
ORDER BY employee DESC 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблицы, результат будет:

| employee |
|----------|
| Ирина    |

---
### Вопрос 45

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
NATURAL JOIN hobby AS h 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван, Музыка
- [ ] Анна, Хоккей
- [ ] Ирина, Плавание
- [x] Иван, Хоккей

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван, Хоккей**:
  - Запрос выполняет `NATURAL JOIN` между таблицами `student` и `hobby`, что автоматически объединяет строки по общему столбцу, которым в данном случае является `id` в таблице `student` и `student_id` в таблице `hobby`. Затем фильтруются результаты, чтобы включить только те строки, где хобби равно 'Хоккей' или 'Чтение'. Поскольку значение 'Хоккей' связано со студентом Иван, и 'Чтение' связано со студенткой Ириной, после сортировки по имени и ограничения одной строкой, результатом будет Иван, Хоккей.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Иван | Хоккей |

---
### Вопрос 46

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT string_agg(t1.student_id::VARCHAR, ',' ORDER BY t1.student_id) AS result 
FROM (
    SELECT s.id 
    FROM student AS s 
    INTERSECT 
    SELECT h.student_id 
    FROM hobby AS h
) AS t1;
```

- [ ] 1,2,3
- [ ] 10,20,30,40
- [x] 1,3
- [ ] 1,1,3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1,3**:
  - Запрос выполняет пересечение (`INTERSECT`) между `id` из таблицы `student` и `student_id` из таблицы `hobby`, чтобы найти общие значения. Затем функция `string_agg` объединяет эти значения в строку, разделяя их запятыми, и сортирует их по `student_id`. В данном случае студентами, имеющими записи как в таблице `student`, так и в таблице `hobby`, являются студенты с `id = 1` и `id = 3`.

### Уточнение по синтаксису запроса

Запрос синтаксически корректен.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| result |
|--------|
| 1,3    |

Хорошо, давайте добавим вопросы с 28 до 46 с ссылками для возвращения к оглавлению.

<details>
  <summary>Вопросы с таблицами и запросами</summary>



