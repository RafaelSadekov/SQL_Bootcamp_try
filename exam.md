
## Оглавление
<details><summary>Вопросы без таблиц и запросов</summary>

1. [Вопросы без таблиц и запросов](#вопросы-без-таблиц-и-запросов) 
    1. [Вопрос 1](#вопрос-1)
    2. [Вопрос 2](#вопрос-2)
    3. [Вопрос 3](#вопрос-3)
    4. [Вопрос 4](#вопрос-4)
    5. [Вопрос 5](#вопрос-5)
    6. [Вопрос 6](#вопрос-6)
    7. [Вопрос 7](#вопрос-7)
    8. [Вопрос 8](#вопрос-8)
    9. [Вопрос 9](#вопрос-9)
    10. [Вопрос 10](#вопрос-10)
    11. [Вопрос 11](#вопрос-11)
    12. [Вопрос 12](#вопрос-12)
    13. [Вопрос 13](#вопрос-13)
    14. [Вопрос 14](#вопрос-14)
    15. [Вопрос 15](#вопрос-15)
    16. [Вопрос 16](#вопрос-16)
    17. [Вопрос 17](#вопрос-17)
    18. [Вопрос 18](#вопрос-18)
    19. [Вопрос 19](#вопрос-19)
    20. [Вопрос 20](#вопрос-20)
    21. [Вопрос 21](#вопрос-21)
    22. [Вопрос 22](#вопрос-22)
    23. [Вопрос 23](#вопрос-23)
    24. [Вопрос 24](#вопрос-24)
    25. [Вопрос 25](#вопрос-25)
    26. [Вопрос 26](#вопрос-26)
    27. [Вопрос 27](#вопрос-27)
    28. [Вопрос 28](#вопрос-28)
    29. [Вопрос 29](#вопрос-29)
    30. [Вопрос 30](#вопрос-30)
    31. [Вопрос 31](#вопрос-31)
    32. [Вопрос 32](#вопрос-32)
    33. [Вопрос 33](#вопрос-33)
    34. [Вопрос 34](#вопрос-34)
    35. [Вопрос 35](#вопрос-35)
    36. [Вопрос 36](#вопрос-36)
    37. [Вопрос 37](#вопрос-37)
    38. [Вопрос 38](#вопрос-38)
    39. [Вопрос 39](#вопрос-39)
    40. [Вопрос 40](#вопрос-40)
    41. [Вопрос 41](#вопрос-41)
    42. [Вопрос 42](#вопрос-42)

</details>
<details><summary>Вопросы с таблицами и запросами</summary>

2. [Вопросы с таблицами и запросами](#вопросы-с-таблицами-и-запросами)
    1. [Вопрос 43](#вопрос-43)
    2. [Вопрос 44](#вопрос-44)
    3. [Вопрос 45](#вопрос-45)
    4. [Вопрос 46](#вопрос-46)
    5. [Вопрос 47](#вопрос-47)
    6. [Вопрос 48](#вопрос-48)
    7. [Вопрос 49](#вопрос-49)
    8. [Вопрос 50](#вопрос-50)
    9. [Вопрос 51](#вопрос-51)
    10. [Вопрос 52](#вопрос-52)
    11. [Вопрос 53](#вопрос-53)
    12. [Вопрос 54](#вопрос-54)
    13. [Вопрос 55](#вопрос-55)
    14. [Вопрос 56](#вопрос-56)
    15. [Вопрос 57](#вопрос-57)
    16. [Вопрос 58](#вопрос-58)
    17. [Вопрос 59](#вопрос-59)
    18. [Вопрос 60](#вопрос-60)
    19. [Вопрос 61](#вопрос-61)
    20. [Вопрос 62](#вопрос-62)
    21. [Вопрос 63](#вопрос-63)
    22. [Вопрос 64](#вопрос-64)
    23. [Вопрос 65](#вопрос-65)
    24. [Вопрос 66](#вопрос-66)
    25. [Вопрос 67](#вопрос-67)
    26. [Вопрос 68](#вопрос-68)
    27. [Вопрос 69](#вопрос-69)
    28. [Вопрос 70](#вопрос-70)
    29. [Вопрос 71](#вопрос-71)
</details>

## Вопросы без таблиц и запросов 

#### Вопрос 1
Что концептуально представляют собой атрибуты сущности в ER-модели?

- [x] Характеристики или свойства сущности, которые описывают данные, относящиеся к этой сущности.
- [ ] Объекты или вещи в системе.
- [ ] Отношения между сущностями.
- [ ] Уникальные идентификаторы сущностей.

[↑ Вернуться к оглавлению](#оглавление)


#### Вопрос 2
Какой из языков обычно используется для описания логических моделей данных?

- [ ] HTML
- [ ] UML
- [ ] JSON
- [x] SQL

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 3
Какое из следующих понятий описывает связь между двумя сущностями в логической модели данных?

- [ ] Хеш-код
- [ ] Тригер
- [ ] Индекс
- [x] Внешний ключ (Foreign Key)

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 4
Что представляет собой первая нормальная форма (1NF) в реляционном дизайне баз данных?

- [x] Все значения атрибутов атомарные (неделимые), каждый столбец содержит только одно значение.
- [ ] Наличие уникального идентификатора для каждой записи.
- [ ] Сущность имеет как минимум один атрибут.
- [ ] Поддержание ссылочной целостности.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 5
Что такое первичный ключ в физической модели данных?

- [x] Уникальный идентификатор строки в таблице, который однозначно определяет каждую запись.
- [ ] Свойство сущности, описывающее данные.
- [ ] Атрибут, который может принимать только уникальные значения.
- [ ] Показатель, определяющий количество связей между сущностями.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 6
Какое действие будет предпринято, если объект CHECK CONSTRAINT не пройдет при вставке или обновлении данных?

- [ ] Данные будут вставлены/обновлены, но с предупреждением.
- [ ] Данные будут вставлены/обновлены без изменений.
- [x] Вызвано исключение, и операция не будет выполнена.
- [ ] Будет выполнена попытка исправить данные автоматически.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 7
Какая команда используется для создания FOREIGN KEY?

- [x] ALTER TABLE ... ADD CONSTRAINT ... FOREIGN KEY
- [ ] CREATE TABLE ... FOREIGN KEY
- [ ] ADD FOREIGN KEY TO TABLE ...
- [ ] MODIFY TABLE ... ADD FOREIGN KEY

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 8
Какая DDL команда используется для создания CHECK CONSTRAINT?

- [x] ALTER TABLE ... ADD CONSTRAINT ... CHECK
- [ ] CREATE TABLE ... CHECK CONSTRAINT
- [ ] ADD CHECK CONSTRAINT TO TABLE ...
- [ ] MODIFY TABLE ... ADD CHECK

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 9
Что подходит под термин <Реляционная база данных>?

- [x] База данных, которая использует реляционную модель для хранения и управления данными.
- [ ] База данных, которая использует объектно-ориентированную модель для хранения данных.
- [ ] Файловая система, использующая реляционные таблицы.
- [ ] База данных, работающая на основе графовых данных.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 10
Что НЕ подходит под термин <Реляционная база данных>?

- [x] Нереляционные базы данных, такие как документно-ориентированные базы.
- [x] Ключ-значение хранилища.
- [x] Колонно-ориентированные базы данных.
- [x] Графовые базы данных.

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 11
Кто управляет доступами к данным в реляционной базе данных?

- [x] DBMS (Database Management System)
- [ ] quercy optimaze
- [ ] transacthion
- [ ] sql serve

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 12
Что означает аббревиатура <CAP> в концепции CAP-теоремы?

- [x] Consistency (Согласованность), Availability (Доступность), Partition Tolerance (Устойчивость к разделению сети)
- [ ] Consistency (Согласованность), Accuracy (Точность), Performance (Производительность)
- [ ] Control (Контроль), Availability (Доступность), Partition (Разделение)
- [ ] Consistency (Согласованность), Availability (Доступность), Performance (Производительность)

[↑ Вернуться к оглавлению](#оглавление)

#### Вопрос 13
Какой принцип гарантии ACID гарантирует, что если транзакция прошла успешно, изменения будут сохранены даже в случае сбоя системы?

- [x] Долговечность (Durability)
- [ ] Атомарность (Atomicity)
- [ ] Согласованность (Consistency)
- [ ] Изолированность (Isolation)

[↑ Вернуться к оглавлению](#оглавление)


### Вопрос 14

При попытке удаления записи из родительской таблицы сущности с установленным внешним ключом (FOREIGN KEY) и параметром `ON DELETE CASCADE`, что произойдет?

- [ ] Запись в родительской таблице будет удалена, а записи в дочерней таблице останутся без изменений.
- [ ] Будет вызвано исключение, и запись не будет удалена.
- [ ] Запись в родительской таблице будет удалена, а связанные записи в дочерней таблице будут обновлены.
- [x] Запись в родительской таблице будет удалена, и все связанные записи в дочерней таблице также будут автоматически удалены.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 15

Какие типы индексов используются в реляционных базах данных?

- [ ] Гибкие (Flexible)
- [ ] Кластерные (Clustered)
- [x] Полнотекстовые (Full-Text)
- [x] Уникальные (Unique)

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 16

Какова цель логического моделирования данных?

- [ ] Обеспечить физическое хранение данных на диске.
- [ ] Оптимизировать запросы к базе данных.
- [ ] Определить структуру базы данных, не зависящую от СУБД.
- [x] Описать данные и их отношения на концептуальном уровне, независимо от физического хранения.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Описать данные и их отношения на концептуальном уровне, независимо от физического хранения**:
  - Логическое моделирование данных направлено на создание абстрактной модели, которая описывает данные и их отношения без привязки к конкретной СУБД или физическим аспектам хранения данных. Эта модель помогает понять структуру данных и их взаимосвязи на высоком уровне.

### Неправильные ответы

- **Обеспечить физическое хранение данных на диске**:
  - Это задача физического моделирования данных, а не логического.

- **Оптимизировать запросы к базе данных**:
  - Оптимизация запросов относится к аспектам реализации и выполнения запросов, что также выходит за рамки логического моделирования данных.

- **Определить структуру базы данных, не зависящую от СУБД**:
  - Логическое моделирование действительно определяет структуру данных, но этот ответ не полностью отражает цель описания данных и их отношений на концептуальном уровне.


### Вопрос 17 

Какой метод используется для нормализации логических моделей данных?

- [ ] Индексация
- [ ] Кэширование
- [x] Нормализация
- [ ] Репликация

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Нормализация**:
  - Нормализация – это метод, используемый для организации атрибутов и таблиц реляционной базы данных для минимизации избыточности данных и предотвращения аномалий при обновлении. Она включает в себя применение различных нормальных форм (1NF, 2NF, 3NF и т.д.), чтобы обеспечить логическую согласованность и целостность данных.

### Неправильные ответы

- **Индексация**:
  - Индексация используется для ускорения выполнения запросов, но не для нормализации данных.

- **Кэширование**:
  - Кэширование используется для хранения часто запрашиваемых данных в памяти для быстрого доступа, но не связано с нормализацией данных.

- **Репликация**:
  - Репликация используется для создания копий данных для обеспечения их доступности и отказоустойчивости, но не для нормализации данных.

### Вопрос 18

Что такое CHECK CONSTRAINT в реляционной базе данных?

- [ ] Ограничение, которое гарантирует, что все значения в столбце являются уникальными.
- [x] Ограничение, которое гарантирует, что все значения в столбце или наборе столбцов удовлетворяют определенному логическому условию.
- [ ] Ограничение, которое устанавливает связь между двумя таблицами.
- [ ] Ограничение, которое предотвращает удаление строк из таблицы.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CHECK CONSTRAINT**:
  - CHECK CONSTRAINT (ограничение проверки) используется для обеспечения того, что все значения в столбце или наборе столбцов соответствуют заданному логическому условию. Это условие может включать проверку диапазона значений, соответствие шаблону или любую другую логическую проверку, определенную пользователем.

### Неправильные ответы

- **Ограничение, которое гарантирует, что все значения в столбце являются уникальными**:
  - Это описание UNIQUE CONSTRAINT, а не CHECK CONSTRAINT.

- **Ограничение, которое устанавливает связь между двумя таблицами**:
  - Это описание FOREIGN KEY CONSTRAINT.

- **Ограничение, которое предотвращает удаление строк из таблицы**:
  - Это не связано с CHECK CONSTRAINT. Это может быть связано с другими мерами безопасности или ограничениями в базе данных.

### Вопрос 19

Какой из перечисленных факторов НЕ влияет на процесс проектирования физической модели базы данных?

- [x] Инструмент проектирования физической модели
- [ ] Сложность бизнес-логики
- [ ] Объем данных
- [ ] Требования к производительности

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Инструмент проектирования физической модели**:
  - Инструмент проектирования может влиять на удобство и скорость работы, но не на сам процесс проектирования физической модели базы данных. Факторы, связанные с архитектурой, объемом данных и производительностью, оказывают непосредственное влияние на проектирование.

### Неправильные ответы

- **Сложность бизнес-логики**:
  - Сложность бизнес-логики влияет на проектирование физической модели, так как более сложная логика может требовать более сложных структур данных и индексов.

- **Объем данных**:
  - Объем данных напрямую влияет на процесс проектирования физической модели, так как большой объем данных может требовать особого подхода к хранению и индексации для обеспечения производительности и масштабируемости.

- **Требования к производительности**:
  - Требования к производительности сильно влияют на процесс проектирования физической модели, так как они определяют, как данные должны быть распределены и индексированы для обеспечения оптимальной производительности.

### Вопрос 20

Какая команда DDL используется для добавления ограничения CHECK CONSTRAINT в уже существующую таблицу?

- [ ] CREATE TABLE ... ADD CONSTRAINT ... CHECK
- [ ] ALTER TABLE ... MODIFY CONSTRAINT ... CHECK
- [x] ALTER TABLE ... ADD CONSTRAINT ... CHECK
- [ ] UPDATE TABLE ... ADD CONSTRAINT ... CHECK

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **ALTER TABLE ... ADD CONSTRAINT ... CHECK**:
  - Эта команда используется для добавления ограничения CHECK в уже существующую таблицу. Она позволяет определить условие, которому должны соответствовать данные в столбце или наборе столбцов.

### Пример использования

```sql
ALTER TABLE table_name
ADD CONSTRAINT constraint_name CHECK (condition);
```
### Вопрос 21

Какая команда DDL используется для создания уникального индекса в реляционной базе данных?

- [ ] CREATE TABLE ... UNIQUE INDEX
- [ ] ALTER TABLE ... ADD UNIQUE INDEX
- [x] CREATE UNIQUE INDEX ... ON ...
- [ ] UPDATE TABLE ... ADD UNIQUE INDEX

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CREATE UNIQUE INDEX ... ON ...**:
  - Эта команда используется для создания уникального индекса на столбце или наборе столбцов в уже существующей таблице. Уникальный индекс гарантирует, что все значения в индексируемых столбцах будут уникальными.

### Пример использования

```sql
CREATE UNIQUE INDEX index_name 
ON table_name (column_name);
```
### Вопрос 22

Что означает уровень изоляции транзакций `READ UNCOMMITTED` в реляционной базе данных?

- [ ] Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями.
- [ ] Транзакция может видеть изменения, которые были зафиксированы другими транзакциями, но не свои собственные.
- [x] Транзакция может видеть все изменения, включая те, которые еще не были зафиксированы другими транзакциями.
- [ ] Транзакция не может видеть никакие изменения, пока они не будут зафиксированы.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Транзакция может видеть все изменения, включая те, которые еще не были зафиксированы другими транзакциями**:
  - Уровень изоляции `READ UNCOMMITTED` позволяет транзакции читать данные, которые были изменены другими транзакциями, но еще не были зафиксированы. Это может привести к ситуации, известной как "грязное чтение" (dirty read), где транзакция читает данные, которые могут быть впоследствии откатаны.

### Неправильные ответы

- **Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями**:
  - Это описание уровня изоляции `READ COMMITTED`.

- **Транзакция может видеть изменения, которые были зафиксированы другими транзакциями, но не свои собственные**:
  - Нет такого стандартного уровня изоляции в SQL.

- **Транзакция не может видеть никакие изменения, пока они не будут зафиксированы**:
  - Это описание более строгого уровня изоляции, например, `SERIALIZABLE`.


### Вопрос 23

Какие из перечисленных операций являются пользовательскими операциями в реляционной базе данных?

- [ ] JSON
- [ ] RAD
- [ ] HTTP
- [x] CRUD

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **CRUD**:
  - CRUD — это аббревиатура, обозначающая четыре основные операции, которые выполняются пользователями в реляционной базе данных: Create (создание), Read (чтение), Update (обновление), Delete (удаление). Эти операции являются основными для работы с данными в базе данных и позволяют пользователям взаимодействовать с хранимыми данными.

### Неправильные ответы

- **JSON**:
  - JSON (JavaScript Object Notation) — это формат данных для передачи и хранения структурированных данных, но не является пользовательской операцией в реляционной базе данных.

- **RAD**:
  - RAD (Rapid Application Development) — это методология быстрой разработки приложений, а не пользовательская операция в реляционной базе данных.

- **HTTP**:
  - HTTP (Hypertext Transfer Protocol) — это протокол передачи гипертекста, используемый в сети Интернет, но не является пользовательской операцией в реляционной базе данных.

### Вопрос 24

Какие типы баз данных наиболее подходят для работы с социальными сетями и рекомендательными системами?

- [ ] Реляционные базы данных (Relational)
- [ ] Документно-ориентированные базы данных (Document)
- [x] NoSQL базы данных (NoSQL)
- [x] Графовые базы данных (Graph)

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **NoSQL базы данных (NoSQL)**:
   - NoSQL базы данных часто используются для работы с большими объемами неструктурированных данных и обеспечивают высокую производительность и масштабируемость. Они могут быть полезны для хранения и обработки данных социальных сетей и рекомендательных систем.

2. **Графовые базы данных (Graph)**:
   - Графовые базы данных особенно подходят для работы с данными социальных сетей, где важны связи и взаимодействия между пользователями. Они позволяют эффективно хранить и запрашивать данные о связях и рекомендациях.

### Неправильные ответы

- **Реляционные базы данных (Relational)**:
  - Хотя реляционные базы данных могут использоваться для некоторых задач в социальных сетях и рекомендательных системах, они могут не справляться с задачами, требующими масштабируемости и гибкости, особенно при работе с большими объемами данных и сложными связями.

- **Документно-ориентированные базы данных (Document)**:
  - Документно-ориентированные базы данных подходят для хранения данных в формате документов, но они не всегда оптимальны для задач, связанных с анализом сложных взаимосвязей, которые характерны для социальных сетей и рекомендательных систем.

### Вопрос 25

Что представляет собой отношение (таблица) в реляционной базе данных?

- [ ] Набор документов, хранящихся в формате JSON.
- [ ] Граф данных, отображающий связи между узлами.
- [x] Множество строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут.
- [ ] Структура данных, организованная в виде ключ-значение.

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Множество строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут**:
  - В реляционной базе данных отношение (таблица) представляет собой двумерную структуру данных, состоящую из строк (записей) и столбцов (атрибутов). Каждая строка в таблице соответствует одной записи, а каждый столбец соответствует одному атрибуту записи. Таблицы используются для хранения и организации данных в реляционных базах данных.

### Неправильные ответы

- **Набор документов, хранящихся в формате JSON**:
  - Это описание документно-ориентированных баз данных, а не реляционных.

- **Граф данных, отображающий связи между узлами**:
  - Это описание графовых баз данных, а не реляционных.

- **Структура данных, организованная в виде ключ-значение**:
  - Это описание базы данных типа ключ-значение, а не реляционных баз данных.

### Вопрос 26

Какие базы данных удовлетворяют свойствам "CA" (Consistency and Availability) из CAP-теоремы?

- [x] PostgreSQL
- [x] MySQL
- [ ] Cassandra
- [ ] HBase

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **PostgreSQL**:
   - PostgreSQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

2. **MySQL**:
   - MySQL — это еще одна реляционная база данных, которая также обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

### Неправильные ответы

- **Cassandra**:
  - Cassandra — это распределенная база данных, которая акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но не всегда на согласованности (Consistency).

- **HBase**:
  - HBase — это распределенная, масштабируемая база данных, которая также акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но не всегда на согласованности (Consistency).

### Вопрос 27

Какие базы данных удовлетворяют свойствам "AP" (Availability and Partition Tolerance) из CAP-теоремы?

- [ ] PostgreSQL
- [ ] MySQL
- [x] Cassandra
- [x] HBase

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильным ответам

1. **Cassandra**:
   - Cassandra — это распределенная база данных, которая обеспечивает высокую доступность (Availability) и устойчивость к разделению сети (Partition Tolerance), но может не гарантировать строгую согласованность (Consistency) во всех случаях.

2. **HBase**:
   - HBase — это распределенная, масштабируемая база данных, которая также акцентирует внимание на доступности (Availability) и устойчивости к разделению сети (Partition Tolerance), но может не гарантировать строгую согласованность (Consistency).

### Неправильные ответы

- **PostgreSQL**:
  - PostgreSQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

- **MySQL**:
  - MySQL — это реляционная база данных, которая обеспечивает согласованность (Consistency) и доступность (Availability), но не всегда устойчива к разделению сети (Partition Tolerance).

  Конечно, вот вопрос с использованием диаграмм, оформленный в формате Markdown:

### Вопрос 28

Какая из следующих диаграмм обычно используется для визуализации ER модели?

- [x] Диаграмма "сущность-связь"
- [ ] Алгоритм Гранта
- [ ] Круговая диаграмма
- [ ] Гистограмма

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 29

Что представляет собой ключевое понятие в логическом моделировании данных?

- [x] Сущность
- [ ] Тип данных
- [ ] Столбец таблицы
- [ ] Таблица

**Пояснение:**

- **Сущность**: В логическом моделировании данных ключевое понятие — это сущность. Сущность представляет собой объект или вещь в реальном мире, о которой необходимо хранить данные. Примеры сущностей включают клиентов, заказы, продукты и т. д.
- **Тип данных**: Это характеристика данных, которая указывает, какого рода данные могут храниться в столбце, например, строка, целое число или дата.
- **Столбец таблицы**: Это элемент структуры таблицы базы данных, который хранит данные определенного типа для всех строк таблицы.
- **Таблица**: Это структура данных в реляционной базе данных, состоящая из строк и столбцов, где каждая строка представляет запись, а каждый столбец — атрибут записи.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 30

Какая нормальная форма требует, чтобы каждый атрибут был функционально зависим только от первичного ключа?

- [ ] 3NF
- [ ] 1NF
- [x] 2NF
- [ ] 4NF

**Пояснение:**

- **2NF (Вторая нормальная форма)**: Вторая нормальная форма требует, чтобы каждый атрибут был полностью функционально зависим от первичного ключа. Это означает, что таблица должна находиться в первой нормальной форме (1NF) и все неключевые атрибуты должны быть зависимы от всего первичного ключа, а не только от его части.
- **1NF (Первая нормальная форма)**: Первая нормальная форма требует, чтобы все значения атрибутов были атомарными (неделимыми), и каждый столбец содержал только одно значение.
- **3NF (Третья нормальная форма)**: Третья нормальная форма требует, чтобы таблица была в 2NF и чтобы все атрибуты были зависимы только от первичного ключа и ни от чего другого.
- **4NF (Четвертая нормальная форма)**: Четвертая нормальная форма требует, чтобы таблица находилась в 3NF и не содержала многозначных зависимостей.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 31

Какой из следующих методов является одним из основных этапов проектирования физической модели данных?

- [ ] Определение требований приложения
- [ ] Построение ER-диаграммы
- [x] Нормализация данных
- [ ] Разработка бизнес-логики

**Пояснение:**

- **Нормализация данных**: Нормализация данных — это процесс организации данных в базе данных таким образом, чтобы уменьшить избыточность и улучшить целостность данных. Это один из ключевых этапов проектирования физической модели данных, поскольку нормализация обеспечивает оптимальную структуру таблиц и связей между ними.
- **Определение требований приложения**: Это важный этап в начале проекта, связанный с анализом требований, но он относится к логическому моделированию данных.
- **Построение ER-диаграммы**: Это этап логического моделирования, который используется для визуализации структуры базы данных, но не для проектирования физической модели.
- **Разработка бизнес-логики**: Это процесс создания логики приложения, который также не относится к проектированию физической модели данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 32

Что является верным утверждением о CHECK ограничении (constraint) в базе данных?

- [ ] CHECK ограничение может быть отключено только администратором базы данных
- [ ] CHECK ограничение применяется только к числовым столбцам
- [x] CHECK ограничение проверяет удовлетворение условия
- [ ] CHECK ограничение применяется только во время вставки строки в таблицу

**Пояснение:**

- **CHECK ограничение проверяет удовлетворение условия**: CHECK ограничение применяется для проверки, удовлетворяет ли значение в столбце или столбцах определенному условию. Это может быть любое логическое выражение.
- **CHECK ограничение может быть отключено только администратором базы данных**: Это утверждение неверно, так как CHECK ограничения могут быть отключены или изменены пользователями, имеющими соответствующие права доступа.
- **CHECK ограничение применяется только к числовым столбцам**: Это утверждение неверно. CHECK ограничения могут применяться к столбцам любого типа данных.
- **CHECK ограничение применяется только во время вставки строки в таблицу**: Это утверждение неверно. CHECK ограничения применяются как при вставке, так и при обновлении строк в таблице.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 33

Связь между родительской и дочерней таблицей при использовании FOREIGN KEY устанавливается:

- [ ] По значению колонки
- [ ] По первичному ключу
- [ ] По названию колонки
- [x] По внешнему ключу

**Пояснение:**

- **По внешнему ключу**: FOREIGN KEY (внешний ключ) используется для установления связи между строками в двух таблицах. Он указывает на столбец или столбцы в одной таблице, значения которых должны соответствовать значению первичного ключа (PRIMARY KEY) в другой таблице. Это помогает поддерживать целостность данных и обеспечить корректные связи между связанными таблицами.
- **По значению колонки**: Это утверждение неверно, так как связь устанавливается не просто по значению, а через ключевую связь между таблицами.
- **По первичному ключу**: Это утверждение частично верно, так как связь через FOREIGN KEY обычно ссылается на первичный ключ другой таблицы, но основная связь все же через FOREIGN KEY.
- **По названию колонки**: Это утверждение неверно, так как связь устанавливается через ключи, а не через названия колонок.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 34

Что делает команда `ROLLBACK` в реляционной базе данных?

- [ ] Применяет изменения в текущей транзакции только для чтения, не внося их в базу данных
- [ ] Подтверждает все изменения
- [x] Отменяет все изменения, сделанные в текущей транзакции
- [ ] Удаляет все изменения из базы данных

**Пояснение:**

- **Отменяет все изменения, сделанные в текущей транзакции**: Команда `ROLLBACK` используется для отмены всех изменений, сделанных в текущей транзакции. Это позволяет вернуться к состоянию базы данных до начала транзакции.
- **Применяет изменения в текущей транзакции только для чтения, не внося их в базу данных**: Это утверждение неверно, так как `ROLLBACK` отменяет изменения, а не применяет их.
- **Подтверждает все изменения**: Это утверждение неверно. Подтверждение изменений выполняется командой `COMMIT`.
- **Удаляет все изменения из базы данных**: Это утверждение неверно, так как `ROLLBACK` отменяет изменения только в рамках текущей транзакции, но не удаляет данные из базы данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 35

Какое из следующих утверждений верно для связи "многие-ко-многим" в логической модели базы данных?

- [ ] Оно не имеет места в логической модели базы данных
- [ ] Может быть реализовано без дополнительной таблицы
- [ ] Оно всегда должно быть разрешено в логической модели базы данных
- [x] Может быть реализовано с использованием дополнительной таблицы связи

**Пояснение:**

- **Может быть реализовано с использованием дополнительной таблицы связи**: В логической модели базы данных связь "многие-ко-многим" обычно реализуется с помощью дополнительной таблицы связи (junction table или associative table). Эта таблица содержит внешние ключи, которые ссылаются на первичные ключи связанных таблиц, и служит для хранения комбинаций этих ключей.
- **Оно не имеет места в логической модели базы данных**: Это утверждение неверно, так как связи "многие-ко-многим" существуют и часто встречаются в логических моделях баз данных.
- **Может быть реализовано без дополнительной таблицы**: Это утверждение неверно, так как для реализации связи "многие-ко-многим" требуется дополнительная таблица.
- **Оно всегда должно быть разрешено в логической модели базы данных**: Это утверждение неверно, так как необходимость в таких связях определяется конкретной моделью данных и требованиями приложения.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 36

Какие из следующих операций являются следствием нарушения CHECK ограничения (constraint)?

- [ ] Автоматическое исправление нарушения
- [x] Откат транзакции
- [ ] Игнорирование нарушения
- [ ] Блокировка таблиц

**Пояснение:**

- **Откат транзакции**: Нарушение CHECK ограничения приводит к откату транзакции. Это означает, что все изменения, сделанные в рамках текущей транзакции, будут отменены, и база данных вернется к состоянию до начала транзакции.
- **Автоматическое исправление нарушения**: Это утверждение неверно. Нарушение CHECK ограничения не может быть автоматически исправлено системой.
- **Игнорирование нарушения**: Это утверждение неверно. Нарушение CHECK ограничения не может быть проигнорировано системой, так как это приведет к нарушению целостности данных.
- **Блокировка таблиц**: Это утверждение неверно. Нарушение CHECK ограничения не приводит к блокировке таблиц.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 37

Какой геометрической фигурой обозначают слабую сущность в ER модели?

- [ ] Двойным овалом
- [ ] Ромбом
- [ ] Овалом
- [x] Двойным прямоугольником

**Пояснение:**

- **Двойным прямоугольником**: В ER моделировании слабая сущность обозначается двойным прямоугольником. Слабая сущность не может быть уникально идентифицирована только своими атрибутами и зависит от связи с другой (сильной) сущностью.
- **Двойным овалом**: Это утверждение неверно. Двойной овал не используется для обозначения слабой сущности.
- **Ромбом**: Это утверждение неверно. Ромб используется для обозначения связей между сущностями.
- **Овалом**: Это утверждение неверно. Овал используется для обозначения атрибутов сущности.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 38

Какой язык программирования используется в реляционных базах данных? (Выберите все подходящие ответы)

- [x] TCL (Transaction Control Language)
- [x] DDL (Data Definition Language)
- [x] DML (Data Manipulation Language)
- [ ] GraphQL

**Пояснение:**

- **TCL (Transaction Control Language)**: TCL — это набор команд, используемых для управления транзакциями в реляционных базах данных. Команды TCL включают COMMIT, ROLLBACK и SAVEPOINT, которые используются для управления завершением и откатом транзакций.
- **DDL (Data Definition Language)**: DDL — это язык определения данных, который используется для создания и изменения структуры базы данных. Команды DDL включают CREATE, ALTER и DROP.
- **DML (Data Manipulation Language)**: DML — это язык манипуляции данными, который используется для вставки, обновления, удаления и чтения данных в базе данных. Команды DML включают INSERT, UPDATE, DELETE и SELECT.
- **GraphQL**: GraphQL — это язык запросов для API, который позволяет клиентам запрашивать только необходимые данные. Он не используется для управления реляционными базами данных.

[↑ Вернуться к оглавлению](#оглавление)

---

### Вопрос 39

Какие факторы могут влиять на решение оптимизатора при выполнении запросов в реляционной базе данных? (Выберите все подходящие ответы)

- [x] Собранная статистика в базе данных
- [ ] Явное указание имен столбцов в SELECT запросе
- [x] Конфигурация реляционной базы данных
- [x] Наличие индексов в базе данных

**Пояснение:**

- **Собранная статистика в базе данных**: Оптимизатор запросов использует статистику для принятия решений о том, как лучше всего выполнить запрос. Статистика включает информацию о распределении значений, количестве строк и других характеристиках данных.
- **Явное указание имен столбцов в SELECT запросе**: Хотя это может улучшить читаемость запроса и предотвратить выбор лишних данных, это не является основным фактором, влияющим на решение оптимизатора.
- **Конфигурация реляционной базы данных**: Конфигурационные параметры базы данных, такие как размер буферного пула, настройки параллелизма и другие, могут влиять на производительность запросов и решения оптимизатора.
- **Наличие индексов в базе данных**: Индексы могут значительно ускорить выполнение запросов, и оптимизатор учитывает наличие и типы индексов при выборе плана выполнения запроса.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 40

Какие модели данных можно организовать, опираясь на реляционную модель? (Выберите все подходящие ответы)

- [ ] Иерархическая модель
- [x] Снежинка
- [x] Звезда
- [x] Data Vault

**Пояснение:**

- **Иерархическая модель**: Иерархическая модель не опирается на реляционную модель. Она организует данные в древовидной структуре, где каждая запись имеет одну родительскую и множество дочерних записей.
- **Снежинка**: Модель "Снежинка" является одной из схем многомерного моделирования данных в хранилищах данных и может быть реализована на основе реляционной модели.
- **Звезда**: Модель "Звезда" — это еще одна схема многомерного моделирования данных, широко используемая в хранилищах данных и базирующаяся на реляционной модели.
- **Data Vault**: Data Vault — это методология моделирования данных, которая также может быть реализована на основе реляционной модели. Она используется для проектирования хранилищ данных и позволяет легко добавлять и изменять данные без нарушения существующей структуры.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 41

Что означает аббревиатура ACID в контексте реляционных баз данных?

- [x] Atomicity, Consistency, Isolation, Durability
- [ ] Accuracy, Consistency, Isolation, Durability
- [ ] Atomicity, Consistency, Isolation, Data Integrity
- [ ] Availability, Consistency, Isolation, Durability

**Пояснение:**

- **Atomicity, Consistency, Isolation, Durability**: ACID — это набор свойств, который обеспечивает надежность транзакций в реляционных базах данных. Эти свойства включают:
  - **Atomicity (Атомарность)**: Гарантирует, что все операции в транзакции будут выполнены полностью или не будут выполнены вовсе.
  - **Consistency (Согласованность)**: Обеспечивает переход базы данных из одного согласованного состояния в другое согласованное состояние.
  - **Isolation (Изоляция)**: Обеспечивает независимость транзакций друг от друга, предотвращая их взаимное влияние.
  - **Durability (Долговечность)**: Обеспечивает сохранение результатов успешно завершенных транзакций даже в случае сбоя системы.
- **Accuracy, Consistency, Isolation, Durability**: Это неверный вариант, так как "Accuracy" не является частью ACID.
- **Atomicity, Consistency, Isolation, Data Integrity**: Это неверный вариант, так как "Data Integrity" не является частью ACID.
- **Availability, Consistency, Isolation, Durability**: Это неверный вариант, так как "Availability" не является частью ACID.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 42

Какое свойство CAP-теоремы предполагает, что распределенная система продолжит функционировать даже в случае аварии некоторых узлов?

- [ ] C + A (Consistency + Availability)
- [ ] C (Consistency)
- [ ] A (Availability)
- [x] P (Partition Tolerance)

**Пояснение:**

- **P (Partition Tolerance)**: Partition Tolerance (устойчивость к разделению) — это свойство, которое обеспечивает способность распределенной системы продолжать работу, даже если в сети возникают разделения (сбой связи между узлами). Это означает, что система сможет функционировать и обрабатывать запросы, несмотря на потерю связи между некоторыми узлами.
- **C + A (Consistency + Availability)**: Это неверный вариант, так как C + A не является одним из свойств CAP-теоремы.
- **C (Consistency)**: Consistency (согласованность) означает, что все узлы в системе видят одни и те же данные в одно и то же время. Это не связано с устойчивостью к разделению.
- **A (Availability)**: Availability (доступность) означает, что каждый запрос, полученный системой, получает ответ (успешный или неуспешный) в течение разумного времени. Это не связано с устойчивостью к разделению.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 43

Что вернет следующий SQL-запрос?

```sql
SELECT CASE 
           WHEN NULL = 5 THEN 'a' 
           WHEN NULL <> 5 THEN 'b' 
           ELSE 'c' 
       END AS result;
```

- [ ] 'a'
- [ ] 'b'
- [x] 'c'
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **'c'**:
  - В SQL любое сравнение с `NULL` всегда возвращает `NULL`. Таким образом, условия `WHEN NULL = 5` и `WHEN NULL <> 5` не выполнятся, и будет возвращено значение из блока `ELSE`, то есть 'c'.

---

### Вопрос 44

Что делает следующий SQL-запрос?

```sql
SELECT SUM(t1.value) 
FROM (SELECT NULL::integer AS value) AS t1;
```

- [ ] Возвращает 0
- [x] Возвращает NULL
- [ ] Возвращает ошибку
- [ ] Возвращает 1

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Возвращает NULL**:
  - Функция `SUM` игнорирует значения `NULL`, но если все значения, которые нужно суммировать, являются `NULL`, результат будет `NULL`.

---

### Вопрос 45

Что вернет следующий SQL-запрос?

```sql
SELECT 1 + 1 AS value 
WHERE 1 = 1 AND 1 = 2;
```

- [ ] 2
- [ ] 1
- [ ] 0
- [x] Ничего (пустой результат)

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ничего (пустой результат)**:
  - Условие `WHERE 1 = 1 AND 1 = 2` всегда ложно, поэтому запрос не вернет ни одной строки.

---
### Вопрос 46

Что вернет следующий SQL-запрос в PostgreSQL?

```sql
SELECT 'Привет' || NULL || 'друзья!' AS result;
```

- [ ] Привет NULL друзья!
- [ ] NULL
- [ ] Привет друзья!
- [x] NULL друзья!

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **NULL**:
  - В PostgreSQL оператор конкатенации `||` возвращает `NULL`, если любой из его операндов равен `NULL`. Таким образом, результатом данного запроса будет `NULL`.

---

### Вопрос 47

Что делает следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE EXISTS (
    SELECT NULL 
    FROM hobby AS h 
    WHERE h.student_id = s.student_id
);
```

- [x] Считает количество студентов, у которых есть хотя бы одно хобби
- [ ] Считает количество студентов, у которых нет хобби
- [ ] Возвращает количество всех записей в таблице `hobby`
- [ ] Возвращает количество всех записей в таблице `student`

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Считает количество студентов, у которых есть хотя бы одно хобби**:
  - Подзапрос проверяет существование записи в таблице `hobby`, связанной со студентом из таблицы `student`. `COUNT(*)` возвращает количество таких студентов.

---

### Вопрос 48


Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT DISTINCT employee AS emp 
FROM employee 
WHERE transaction BETWEEN 50 AND 300 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван
- [x] Анна
- [ ] Ирина
- [ ] NULL

**Пояснение:**

- **Анна**: Запрос выбирает уникальные значения `employee`, у которых `transaction` находится в диапазоне от 50 до 300 включительно. Затем результат сортируется по имени `employee`, и выбирается первая строка. Анна будет первой в отсортированном списке.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 49

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT string_agg(t1.id::VARCHAR, ',' ORDER BY t1.id) AS result 
FROM (
    SELECT s.id 
    FROM student AS s 
    UNION ALL 
    SELECT h.student_id 
    FROM hobby AS h
) AS t1;
```

- [x] 1,1,1,2,3,3,4
- [ ] 1,1,2,3,3,4
- [ ] Ошибка
- [ ] 1,2,3,3

**Пояснение:**

- **1,1,1,2,3,3,4**: Запрос объединяет все `id` из таблицы `student` и `student_id` из таблицы `hobby` с использованием `UNION ALL`, что сохраняет все дубликаты. Затем `string_agg` объединяет эти значения в строку, разделяя их запятыми, и сортирует по `id`.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 50

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    RIGHT JOIN hobby AS h 
    ON s.id = h.student_id 
    ORDER BY s.name NULLS FIRST 
    LIMIT 1
), 
_b AS (
    SELECT 1/0 AS res
) 
SELECT * 
FROM _a 
INNER JOIN _b;
```

- [x] Синтаксическая ошибка
- [ ] Иван, Музыка
- [ ] NULL, Плавание
- [ ] Анна, NULL

**Пояснение:**

- **Синтаксическая ошибка**: Этот вариант верен, так как попытка выполнения запроса с делением на ноль (`SELECT 1/0 AS res`) приведет к ошибке выполнения.
- **Иван, Музыка**: Этот вариант неверен, так как запрос будет прерван ошибкой деления на ноль.
- **NULL, Плавание**: Этот вариант неверен, так как запрос будет прерван ошибкой деления на ноль.
- **Анна, NULL**: Этот вариант неверен, так как запрос будет прерван ошибкой деления на ноль.

[↑ Вернуться к оглавлению](#оглавление)

---
### Вопрос 51

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT NULL 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [ ] 1
- [x] 1
- [ ] 2
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос выбирает количество студентов, у которых нет соответствующих записей в таблице `hobby`. В данном случае, студент с `id = 2` (Анна) не имеет записей в таблице `hobby`, поэтому результатом будет `1`.

---

### Вопрос 52

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE id NOT IN (
    SELECT student_id 
    FROM hobby 
    WHERE hobby ILIKE '%Хоккей%'
);
```

- [ ] 1
- [ ] 2
- [x] 2
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **2**:
  - Запрос выбирает количество студентов, у которых нет хобби, содержащего слово "Хоккей". В данном случае, только у студента с `id = 1` (Иван) есть хобби "Хоккей". Поэтому студенты с `id = 2` (Анна) и `id = 3` (Ирина) будут включены в результат, что дает итоговый счет 2.
  `ILIKE` используется в PostgreSQL для нечувствительного к регистру поиска по шаблону. 
---

### Вопрос 53

Имеется следующая таблица `student`:

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

Что вернет следующий SQL-запрос?

```sql
SELECT reg_num 
FROM student 
ORDER BY reg_num NULLS LAST 
LIMIT 1;
```

- [ ] 123
- [ ] 456
- [ ] NULL
- [x] 123

### Пояснение к правильному ответу

- **123**:
  - Запрос выбирает значения столбца `reg_num` из таблицы `student`, сортируя их по возрастанию с размещением значений `NULL` в конце (`NULLS LAST`), и ограничивает результат одной строкой (`LIMIT 1`). Поскольку 123 является наименьшим ненулевым значением, оно будет первым в отсортированном списке, и результатом будет 123.

---
### Вопрос 54

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
CROSS JOIN hobby AS h 
ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван, Музыка
- [ ] Анна, Хоккей
- [ ] Ирина, Плавание
- [x] Иван, Хоккей

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван, Хоккей**:
  - Запрос выполняет `CROSS JOIN` (в данном случае это синтаксическая ошибка, так как для `CROSS JOIN` не требуется условие `ON`) между таблицами `student` и `hobby`, и затем фильтрует результаты, чтобы включить только те строки, где хобби равно 'Хоккей' или 'Чтение'. Поскольку значение 'Хоккей' связано со студентом Иван, и 'Чтение' связано со студенткой Ириной, после сортировки по имени и ограничения одной строкой, результатом будет Иван, Хоккей.

### Уточнение по синтаксису запроса

Запрос должен использовать `INNER JOIN` или `JOIN`, так как `CROSS JOIN` не требует условия `ON`.

Исправленный запрос:

```sql
SELECT s.name, h.hobby 
FROM student AS s 
JOIN hobby AS h 
ON s.id = h.student_id 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Иван | Хоккей |

---

### Вопрос 55

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
WITH _a AS (
    SELECT s.name, h.hobby 
    FROM student AS s 
    LEFT JOIN hobby AS h 
    ON s.id = h.student_id
)
SELECT * 
FROM _a 
ORDER BY name NULLS FIRST 
LIMIT 1;
```

- [ ] Анна, NULL
- [ ] Иван, Хоккей
- [x] Анна, NULL
- [ ] Ирина, Чтение

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Анна, NULL**:
  - Запрос использует CTE (`WITH _a AS ...`), который выполняет левое соединение (`LEFT JOIN`) таблиц `student` и `hobby` по условию `s.id = h.student_id`. Затем основной запрос выбирает все строки из CTE `_a`, сортирует их по имени, помещая значения `NULL` в начало (`NULLS FIRST`), и ограничивает результат одной строкой (`LIMIT 1`). Поскольку Анна не имеет записи в таблице `hobby`, результат будет `Анна, NULL`.

### Уточнение по синтаксису запроса

Запрос синтаксически корректен и не требует изменений.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Анна | NULL  |

---

### Вопрос 56

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT (2 + 2 * 2) 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [ ] 1
- [ ] 2
- [x] 1
- [ ] 3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос выбирает количество студентов, у которых нет соответствующих записей в таблице `hobby`. В данном случае, студент с `id = 2` (Анна) не имеет записей в таблице `hobby`, поэтому результатом будет `1`.

### Уточнение по синтаксису запроса

В оригинальном запросе есть синтаксическая ошибка: `when` должно быть `where`.

Исправленный запрос:

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE NOT EXISTS (
    SELECT (2 + 2 * 2) 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблиц, результат будет:

| count |
|-------|
| 1     |

### Вопрос 57

Имеется следующая таблица `student`:

#### Таблица `student`
| id | name  | reg_num |
|----|-------|---------|
| 1  | Иван  | 123     |
| 2  | Анна  | NULL    |
| 3  | Ирина | 456     |

Что вернет следующий SQL-запрос?

```sql
SELECT reg_num 
FROM student 
ORDER BY CASE 
            WHEN reg_num IS NULL THEN 1 
            ELSE reg_num 
         END 
LIMIT 1;
```

- [ ] 123
- [ ] 456
- [x] 1
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1**:
  - Запрос сортирует таблицу `student` по `reg_num`, используя конструкцию `CASE WHEN reg_num IS NULL THEN 1 ELSE reg_num END`. Это приводит к тому, что значения `NULL` обрабатываются как 1. После сортировки результаты ограничиваются одной строкой (`LIMIT 1`). Поскольку строка с `reg_num` равным `NULL` будет заменена на 1 в сортировке, она будет первой в списке. 

### Уточнение по синтаксису запроса

В оригинальном запросе есть синтаксическая ошибка: `them` должно быть `then`.

Исправленный запрос:

```sql
SELECT reg_num 
FROM student 
ORDER BY CASE 
            WHEN reg_num IS NULL THEN 1 
            ELSE reg_num 
         END 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблицы, результат будет:

| reg_num |
|---------|
| 1       |

---
### Вопрос 58

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT employee, SUM(transaction) 
FROM employee 
GROUP BY employee 
HAVING MIN(transaction) = MAX(transaction) 
ORDER BY employee 
LIMIT 1;
```

- [ ] Иван, 430
- [ ] Анна, 245
- [x] Ирина, 50
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ирина, 50**:
  - Запрос группирует строки по столбцу `employee`, а затем применяет условие `HAVING MIN(transaction) = MAX(transaction)`, чтобы выбрать только тех сотрудников, у которых все значения `transaction` одинаковы. В данном случае это применимо только к Ирине, так как у неё одна транзакция равна 50. Запрос затем суммирует транзакции для каждого сотрудника, сортирует результат по имени и ограничивает результат одной строкой (`LIMIT 1`). Иван и Анна имеют разные значения транзакций, поэтому они не будут включены в результат.

### Уточнение по синтаксису запроса

Запрос синтаксически корректен и не требует изменений.

### Пример выполнения запроса

С учетом данных таблицы, результат будет:

| employee | sum(transaction) |
|----------|------------------|
| Ирина    | 50               |

---
### Вопрос 59

Имеется следующая таблица `employee`:

#### Таблица `employee`
| id | employee | transaction |
|----|----------|-------------|
| 1  | Иван     | 100         |
| 2  | Анна     | 200         |
| 3  | Ирина    | 50          |
| 4  | Иван     | 330         |
| 5  | Анна     | 45          |

Что вернет следующий SQL-запрос?

```sql
SELECT employee 
FROM (
    SELECT employee, 
           ROW_NUMBER() OVER (ORDER BY transaction) AS row_num 
    FROM employee 
    GROUP BY employee
) AS t1 
WHERE t1.row_num != 2 
ORDER BY employee DESC 
LIMIT 1;
```

- [ ] Иван
- [ ] Анна
- [x] Ирина
- [ ] NULL

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Ирина**:
  - Запрос использует оконную функцию `ROW_NUMBER()` для нумерации строк на основе значения `transaction`, группирует данные по `employee`. Затем внешний запрос выбирает всех сотрудников, у которых `row_num` не равно 2, сортирует результат по имени сотрудника в порядке убывания и ограничивает результат одной строкой (`LIMIT 1`). Поскольку `ROW_NUMBER()` присваивает номера строкам на основе значения `transaction`, и учитывая, что у нас только три уникальных имени, результатом будет Ирина, так как у неё наименьшее значение `transaction`.

### Уточнение по синтаксису запроса

В оригинальном запросе есть синтаксическая ошибка: необходимо учитывать все строки, чтобы `ROW_NUMBER()` работал корректно. Группировка по одному столбцу приводит к некорректной работе `ROW_NUMBER()`.

Исправленный запрос:

```sql
SELECT employee 
FROM (
    SELECT employee, 
           ROW_NUMBER() OVER (ORDER BY transaction) AS row_num 
    FROM employee
) AS t1 
WHERE t1.row_num != 2 
ORDER BY employee DESC 
LIMIT 1;
```

### Пример выполнения запроса

С учетом исправленного синтаксиса и данных таблицы, результат будет:

| employee |
|----------|
| Ирина    |

---
### Вопрос 60

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
NATURAL JOIN hobby AS h 
WHERE h.hobby = 'Хоккей' OR h.hobby = 'Чтение' 
ORDER BY 1 
LIMIT 1;
```

- [ ] Иван, Музыка
- [ ] Анна, Хоккей
- [ ] Ирина, Плавание
- [x] Иван, Хоккей

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **Иван, Хоккей**:
  - Запрос выполняет `NATURAL JOIN` между таблицами `student` и `hobby`, что автоматически объединяет строки по общему столбцу, которым в данном случае является `id` в таблице `student` и `student_id` в таблице `hobby`. Затем фильтруются результаты, чтобы включить только те строки, где хобби равно 'Хоккей' или 'Чтение'. Поскольку значение 'Хоккей' связано со студентом Иван, и 'Чтение' связано со студенткой Ириной, после сортировки по имени и ограничения одной строкой, результатом будет Иван, Хоккей.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| name | hobby |
|------|-------|
| Иван | Хоккей |

---
### Вопрос 61

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT string_agg(t1.student_id::VARCHAR, ',' ORDER BY t1.student_id) AS result 
FROM (
    SELECT s.id 
    FROM student AS s 
    INTERSECT 
    SELECT h.student_id 
    FROM hobby AS h
) AS t1;
```

- [ ] 1,2,3
- [ ] 10,20,30,40
- [x] 1,3
- [ ] 1,1,3

[↑ Вернуться к оглавлению](#оглавление)

### Пояснение к правильному ответу

- **1,3**:
  - Запрос выполняет пересечение (`INTERSECT`) между `id` из таблицы `student` и `student_id` из таблицы `hobby`, чтобы найти общие значения. Затем функция `string_agg` объединяет эти значения в строку, разделяя их запятыми, и сортирует их по `student_id`. В данном случае студентами, имеющими записи как в таблице `student`, так и в таблице `hobby`, являются студенты с `id = 1` и `id = 3`.

### Уточнение по синтаксису запроса

Запрос синтаксически корректен.

### Пример выполнения запроса

С учетом данных таблиц, результат будет:

| result |
|--------|
| 1,3    |

### Вопрос 62


### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |


Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE EXISTS (
    SELECT 0 
    FROM hobby AS h 
    WHERE h.student_id = s.id 
    LIMIT 1
);
```

- [x] 2
- [ ] Данный запрос не вернет ни одной строки
- [ ] 3
- [ ] 0

**Пояснение:**

- **2**: Запрос подсчитывает количество записей в таблице `student`, для которых существует хотя бы одна соответствующая запись в таблице `hobby`. В данном случае, только для двух студентов (`id = 1` и `id = 3`) существуют соответствующие записи в таблице `hobby`, поэтому результатом будет 2.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 63

Имеется следующая таблица `hobby`:

#### Таблица `hobby`
| id | student | hobby   |
|----|---------|---------|
| 1  | Иван    | Хоккей  |
| 2  | Анна    | Блог    |
| 3  | Ирина   | Чтение  |
| 4  | Иван    | Футбол  |
| 5  | Анна    | Спорт   |

Что вернет следующий SQL-запрос?

```sql
SELECT student 
FROM hobby 
GROUP BY student 
HAVING student LIKE '%Анна%' AND id = 2 
LIMIT 1;
```

- [ ] Анна
- [x] Синтаксическая ошибка
- [ ] Ни одна строка
- [ ] NULL

**Пояснение:**

- **Анна**: Этот вариант неверен, так как условие `HAVING student LIKE '%Анна%' AND id = 2` неверно.
- **Синтаксическая ошибка**: Этот вариант верен, так как в запросе есть синтаксическая ошибка — использование `id` в условиях `HAVING`, где оно не группируется.
- **Ни одна строка**: Этот вариант неверен, так как синтаксическая ошибка не позволяет запросу выполниться.
- **NULL**: Этот вариант неверен, так как запрос не выполнится из-за синтаксической ошибки.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 64

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT * 
FROM student AS s 
NATURAL JOIN hobby AS h;
```

- [ ] r = 3, c = 4
- [ ] r = 4, c = 4
- [x] r = 2, c = 4
- [ ] r = 14, c = 4

**Пояснение:**

- **r = 3, c = 4**: Этот вариант неверен, так как результат запроса будет содержать только строки, которые соответствуют объединению (join) по общим столбцам (в данном случае `id` и `student_id`), и таких строк будет 2.
- **r = 4, c = 4**: Этот вариант неверен, так как результат запроса будет содержать меньше строк.
- **r = 2, c = 4**: Этот вариант верен, так как результат запроса будет содержать 2 строки и 4 столбца (id, name, student_id, hobby).
- **r = 14, c = 4**: Этот вариант неверен, так как результат запроса не может содержать столько строк.

**Проверка данных:**

Объединенные строки:
1. Иван - Хоккей
2. Иван - Музыка

Таким образом, при NATURAL JOIN строки будут объединены по `id` и `student_id`, и результат будет включать только 2 строки.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 65

Что вернет следующий SQL-запрос?

```sql
SELECT MIN(t1.value) 
FROM (SELECT NULL::Integer AS value) AS t1;
```

- [x] NULL
- [ ] Синтаксическая ошибка
- [ ] 1
- [ ] 0

**Пояснение:**

- **NULL**: Этот вариант верен, так как запрос выбирает минимальное значение из единственной строки, где `value` имеет значение `NULL`. Функция `MIN` при работе с единственным значением `NULL` вернет `NULL`.
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.
- **1**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 1.
- **0**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 0.

[↑ Вернуться к оглавлению](#оглавление)

Конечно, вот следующий вопрос, оформленный в формате Markdown:

### Вопрос 66

Что вернет следующий SQL-запрос?

```sql
SELECT 1+1 AS value 
WHERE 1=1;
```

- [ ] Синтаксическая ошибка
- [ ] Ни одной строки
- [ ] NULL
- [x] 2

**Пояснение:**

- **2**: Этот вариант верен, так как условие `WHERE 1=1` всегда истинно. Запрос выполнится и вернет результат 1+1, который равен 2.
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.
- **Ни одной строки**: Этот вариант неверен, так как условие `WHERE 1=1` всегда истинно, и запрос вернет одну строку с результатом 2.
- **NULL**: Этот вариант неверен, так как запрос вернет результат вычисления 1+1, который равен 2.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 66

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
FULL JOIN hobby AS h 
ON s.id = h.student_id 
ORDER BY h.hobby NULLS LAST;
```

- [ ] Анна, NULL
- [ ] Иван, Музыка
- [ ] Ни одной строки
- [x] NULL, Плавание

**Пояснение:**

- **Анна, NULL**: Этот вариант неверен, так как Анна имеет соответствующую запись в таблице `hobby` (Плавание).
- **Иван, Музыка**: Этот вариант неверен, так как при сортировке `NULL` значений они будут размещены последними.
- **Ни одной строки**: Этот вариант неверен, так как результат запроса будет содержать строки.
- **NULL, Плавание**: Этот вариант верен, так как `FULL JOIN` объединяет все записи из обеих таблиц, включая строки, не имеющие соответствия. При сортировке по `hobby` с `NULLS LAST`, строки с `NULL` в столбце `hobby` будут последними. Таким образом, последняя строка будет иметь `NULL` в `name` и `Плавание` в `hobby`.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 67
Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |
| 40 | 4          | Плавание  |

Что вернет следующий SQL-запрос?

```sql
SELECT s.name, h.hobby 
FROM student AS s 
FULL JOIN hobby AS h 
ON s.id = h.student_id 
ORDER BY h.hobby NULLS LAST 
LIMIT 1;
```

- [ ] Анна, NULL
- [ ] Иван, Музыка
- [ ] Ни одной строки
- [x] Иван, Музыка

**Пояснение:**

Запрос выполняет `FULL JOIN`, который объединяет строки из обеих таблиц, даже если в одной из таблиц нет соответствующих строк. После этого происходит сортировка по столбцу `hobby`, при этом `NULL` значения перемещаются в конец. Поскольку используется `LIMIT 1`, вернется первая строка после сортировки.

Результат сортировки:
| name | hobby   |
|------|---------|
| Иван | Музыка  |
| Иван | Хоккей  |
| Ирина| Чтение  |
| NULL | Плавание|
| Анна | NULL    |

Так как используется `LIMIT 1`, возвращается первая строка:
- **Иван, Музыка**

### Ответ:
- [x] Иван, Музыка

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 68

Что вернет следующий SQL-запрос?

```sql
SELECT MAX(t1.value) 
FROM (SELECT NULL::integer AS value) AS t1;
```

- [ ] 0
- [x] NULL
- [ ] 1
- [ ] Синтаксическая ошибка

**Пояснение:**

- **NULL**: Этот вариант верен, так как запрос выбирает максимальное значение из единственной строки, где `value` имеет значение `NULL`. Функция `MAX` при работе с единственным значением `NULL` вернет `NULL`.
- **0**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 0.
- **1**: Этот вариант неверен, так как значение `NULL` не может быть интерпретировано как 1.
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 69

Что вернет следующий SQL-запрос?

```sql
SELECT 1+1 AS value 
WHERE 1=1 AND NOT (SELECT true);
```

- [x] Синтаксическая ошибка
- [ ] Ни одной строки
- [ ] 2
- [ ] NULL

**Пояснение:**

- **Синтаксическая ошибка**: Этот вариант верен. Подзапрос в условии `WHERE` должен возвращать скалярное значение (одно значение). Однако выражение `SELECT true` возвращает результат в виде множества, что вызывает синтаксическую ошибку.
- **Ни одной строки**: Этот вариант неверен, так как запрос синтаксически некорректен и не будет выполнен.
- **2**: Этот вариант неверен, так как запрос синтаксически некорректен и не будет выполнен.
- **NULL**: Этот вариант неверен, так как запрос синтаксически некорректен и не будет выполнен.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 70

Имеются следующие таблицы `student` и `hobby`:

#### Таблица `student`
| id | name  |
|----|-------|
| 1  | Иван  |
| 2  | Анна  |
| 3  | Ирина |

#### Таблица `hobby`
| id | student_id | hobby     |
|----|------------|-----------|
| 10 | 1          | Хоккей    |
| 20 | 1          | Музыка    |
| 30 | 3          | Чтение    |

Что вернет следующий SQL-запрос?

```sql
SELECT COUNT(*) 
FROM student AS s 
WHERE id IN (
    SELECT student_id 
    FROM hobby 
    WHERE hobby LIKE '%Хоккей%'
);
```

- [ ] NULL
- [ ] Ни одной строки
- [ ] 3
- [x] 1

**Пояснение:**

- **NULL**: Этот вариант неверен, так как запрос возвращает количество строк.
- **Ни одной строки**: Этот вариант неверен, так как запрос возвращает количество строк.
- **3**: Этот вариант неверен, так как только один студент (Иван) имеет хобби, которое соответствует условию `LIKE '%Хоккей%'`.
- **2**: Этот вариант верен, так как только один студент (Иван) имеет хобби, которое соответствует условию `LIKE '%Хоккей%'`.

[↑ Вернуться к оглавлению](#оглавление)

### Вопрос 71

Имеется следующая таблица `hobby`:

#### Таблица `hobby`
| id | student | hobby   |
|----|---------|---------|
| 1  | Иван    | Хоккей  |
| 2  | Анна    | Блог    |
| 3  | Ирина   | Чтение  |
| 4  | Иван    | Футбол  |
| 5  | Анна    | Спорт   |

Что вернет следующий SQL-запрос?

```sql
SELECT student 
FROM hobby 
GROUP BY student 
HAVING student NOT IN ('Анна','Ирина') AND COUNT(*) > 1 
LIMIT 1;
```

- [x] Иван
- [ ] Синтаксическая ошибка
- [ ] Ни одной строки
- [ ] Ирина

**Пояснение:**

- **Иван**: Этот вариант верен, так как только у Ивана есть более одного хобби (Хоккей и Футбол) и его имя не входит в список ('Анна', 'Ирина').
- **Синтаксическая ошибка**: Этот вариант неверен, так как запрос синтаксически корректен.
- **Ни одной строки**: Этот вариант неверен, так как результат запроса будет содержать строку.
- **Ирина**: Этот вариант неверен, так как у Ирины только одно хобби и её имя входит в список ('Анна', 'Ирина').

[↑ Вернуться к оглавлению](#оглавление)